<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="color-scheme" content="light dark">




<meta name="author" content="OrcasCode">
<meta name="description" content="GKCTF2020的密码学题目相对而言比较简单，古典密码学题目偏多。而且密码学题目也只有四道题目
0x0 小学生的密码学打开题目描述，查看题目描述内容：
e(x)=11x&#43;6(mod26) 密文：welcylk （flag为base64形式） 看样子是仿射密码，直接逆就好了，写个python脚本解决吧：
import gmpy2 import string import base64 m = gmpy2.invert(11,26) table = string.ascii_lowercase # print table cipher = &#34;welcylk&#34; plainer = &#34;&#34; for i in cipher: x = table.index(i) j = (x-6)*m %26 # print j plainer &#43;= table[j] flag = &#34;flag{&#34;&#43;base64.b64encode(plainer) &#43;&#34;}&#34; print flag 运行脚本，得到flag：
flag{c29yY2VyeQ==} 0x1 汉字的秘密题目描述：
你能看出汉字的奥秘吗？ 答案形式：flag{小写字母} 和汉字相关的密码，又是考察古典密码，估计是当铺密码
下载附件，发现附件是一个doc文件，查看附件内容：
王壮 夫工 王中 王夫 由由井 井人 夫中 夫夫 井王 土土 夫由 土夫 井中 士夫 王工 王人 土由 由口夫 看样子是当铺密码，没错了，写个脚本处理一下吧：">
<meta name="keywords" content="blog,developer,personal">

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="GKCTF2020 CRYPTO_writeup"/>
<meta name="twitter:description" content="GKCTF2020的密码学题目相对而言比较简单，古典密码学题目偏多。而且密码学题目也只有四道题目
0x0 小学生的密码学打开题目描述，查看题目描述内容：
e(x)=11x&#43;6(mod26) 密文：welcylk （flag为base64形式） 看样子是仿射密码，直接逆就好了，写个python脚本解决吧：
import gmpy2 import string import base64 m = gmpy2.invert(11,26) table = string.ascii_lowercase # print table cipher = &#34;welcylk&#34; plainer = &#34;&#34; for i in cipher: x = table.index(i) j = (x-6)*m %26 # print j plainer &#43;= table[j] flag = &#34;flag{&#34;&#43;base64.b64encode(plainer) &#43;&#34;}&#34; print flag 运行脚本，得到flag：
flag{c29yY2VyeQ==} 0x1 汉字的秘密题目描述：
你能看出汉字的奥秘吗？ 答案形式：flag{小写字母} 和汉字相关的密码，又是考察古典密码，估计是当铺密码
下载附件，发现附件是一个doc文件，查看附件内容：
王壮 夫工 王中 王夫 由由井 井人 夫中 夫夫 井王 土土 夫由 土夫 井中 士夫 王工 王人 土由 由口夫 看样子是当铺密码，没错了，写个脚本处理一下吧："/>

<meta property="og:title" content="GKCTF2020 CRYPTO_writeup" />
<meta property="og:description" content="GKCTF2020的密码学题目相对而言比较简单，古典密码学题目偏多。而且密码学题目也只有四道题目
0x0 小学生的密码学打开题目描述，查看题目描述内容：
e(x)=11x&#43;6(mod26) 密文：welcylk （flag为base64形式） 看样子是仿射密码，直接逆就好了，写个python脚本解决吧：
import gmpy2 import string import base64 m = gmpy2.invert(11,26) table = string.ascii_lowercase # print table cipher = &#34;welcylk&#34; plainer = &#34;&#34; for i in cipher: x = table.index(i) j = (x-6)*m %26 # print j plainer &#43;= table[j] flag = &#34;flag{&#34;&#43;base64.b64encode(plainer) &#43;&#34;}&#34; print flag 运行脚本，得到flag：
flag{c29yY2VyeQ==} 0x1 汉字的秘密题目描述：
你能看出汉字的奥秘吗？ 答案形式：flag{小写字母} 和汉字相关的密码，又是考察古典密码，估计是当铺密码
下载附件，发现附件是一个doc文件，查看附件内容：
王壮 夫工 王中 王夫 由由井 井人 夫中 夫夫 井王 土土 夫由 土夫 井中 士夫 王工 王人 土由 由口夫 看样子是当铺密码，没错了，写个脚本处理一下吧：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.codetea.top/posts/gkctf2020-crypto_writeup/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-06-26T16:53:12+08:00" />
<meta property="article:modified_time" content="2021-06-26T16:53:12+08:00" />




  <title>OPdbg</title>

  
  <link rel="canonical" href="https://www.codetea.top/posts/gkctf2020-crypto_writeup/">
  

  <link rel="preload" href="/fonts/forkawesome-webfont.woff2?v=1.2.0" as="font" type="font/woff2" crossorigin>


  
  
  <link rel="stylesheet" href="/css/coder.min.6b1a4fbc48955b72aea7913e43fabeb45e8bc120da5aa41b598dd33adcac4b59.css" integrity="sha256-axpPvEiVW3Kup5E&#43;Q/q&#43;tF6LwSDaWqQbWY3TOtysS1k=" crossorigin="anonymous" media="screen" />





  
  
    
    
    <link rel="stylesheet" href="/css/coder-dark.min.39e41a7f16bdf8cb16e43cae7d714fa1016f1d2d2898a5b3f27f42c9979204e2.css" integrity="sha256-OeQafxa9&#43;MsW5DyufXFPoQFvHS0omKWz8n9CyZeSBOI=" crossorigin="anonymous" media="screen" />
  



   





  <link rel="icon" type="image/png" href="/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="/favicon-16x16.png" sizes="16x16">

<link rel="apple-touch-icon" href="/images/apple-touch-icon.png">
<link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

<link rel="manifest" href="/site.webmanifest">
<link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#5bbad5">


  

  <meta name="generator" content="Hugo 0.101.0" />


  

<link href="https://cdn.bootcdn.net/ajax/libs/highlight.js/11.5.1/styles/atom-one-dark-reasonable.min.css" rel="stylesheet">
<script src="https://cdn.bootcdn.net/ajax/libs/highlight.js/11.5.1/highlight.min.js"></script>
<script src="https://cdn.bootcdn.net/ajax/libs/highlight.js/11.5.1/languages/armasm.min.js"></script>
<script src="https://cdn.bootcdn.net/ajax/libs/highlight.js/11.5.1/languages/mipsasm.min.js"></script>
<script src="https://cdn.bootcdn.net/ajax/libs/highlight.js/11.5.1/languages/wasm.min.js"></script>
<script src="https://cdn.bootcdn.net/ajax/libs/highlight.js/11.5.1/languages/x86asm.min.js"></script>
<script>hljs.highlightAll();</script>
</head>







<body class="preload-transitions colorscheme-auto">
  
<div class="float-container">
    <a id="dark-mode-toggle" class="colorscheme-toggle">
        <i class="fa fa-adjust fa-fw" aria-hidden="true"></i>
    </a>
</div>


  <main class="wrapper">
    <nav class="navigation">
  <section class="container">
    <a class="navigation-title" href="/">
      OPdbg
    </a>
    
      <input type="checkbox" id="menu-toggle" />
      <label class="menu-button float-right" for="menu-toggle">
        <i class="fa fa-bars fa-fw" aria-hidden="true"></i>
      </label>
      <ul class="navigation-list">
        
          
            <li class="navigation-item">
              <a class="navigation-link" href="/about/">About</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="/posts/">Posts</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="/categories/">Categories</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="/tags/">Tags</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="/link/">Link</a>
            </li>
          
        
        
      </ul>
    
  </section>
</nav>


    <div class="content">
      
  <section class="container post">
    <article>
      <header>
        <div class="post-title">
          <h1 class="title">
            <a class="title-link" href="https://www.codetea.top/posts/gkctf2020-crypto_writeup/">
              GKCTF2020 CRYPTO_writeup
            </a>
          </h1>
        </div>
        <div class="post-meta">
          <div class="date">
            <span class="posted-on">
              <i class="fa fa-calendar" aria-hidden="true"></i>
              <time datetime="2021-06-26T16:53:12&#43;08:00">
                June 26, 2021
              </time>
            </span>
            <span class="reading-time">
              <i class="fa fa-clock-o" aria-hidden="true"></i>
              4-minute read
            </span>
          </div>
          
          <div class="categories">
  <i class="fa fa-folder" aria-hidden="true"></i>
    <a href="/categories/practice/">practice</a></div>

          <div class="tags">
  <i class="fa fa-tag" aria-hidden="true"></i>
    <span class="tag">
      <a href="/tags/ctf/">ctf</a>
    </span>
      <span class="separator">•</span>
    <span class="tag">
      <a href="/tags/writeup/">writeup</a>
    </span></div>

        </div>
      </header>

      <div>
        
        <p>GKCTF2020的密码学题目相对而言比较简单，古典密码学题目偏多。而且密码学题目也只有四道题目</p>
<p><img src="/images/GKCTF2020-Crypto_writeup/WechatIMG1350.jpeg" alt="img"></p>
<h2 id="0x0-小学生的密码学">
  0x0 小学生的密码学
  <a class="heading-link" href="#0x0-%e5%b0%8f%e5%ad%a6%e7%94%9f%e7%9a%84%e5%af%86%e7%a0%81%e5%ad%a6">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h2>
<p>打开题目描述，查看题目描述内容：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>e(x)=11x+6(mod26)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>密文：welcylk
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>（flag为base64形式）
</span></span></code></pre></div><p>看样子是仿射密码，直接逆就好了，写个python脚本解决吧：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="font-weight:bold">import</span> <span style="font-weight:bold">gmpy2</span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">import</span> <span style="font-weight:bold">string</span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">import</span> <span style="font-weight:bold">base64</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>m = gmpy2.invert(11,26)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>table = string.ascii_lowercase
</span></span><span style="display:flex;"><span><span style="font-style:italic"># print table</span>
</span></span><span style="display:flex;"><span>cipher = <span style="font-style:italic">&#34;welcylk&#34;</span>
</span></span><span style="display:flex;"><span>plainer = <span style="font-style:italic">&#34;&#34;</span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">for</span> i <span style="font-weight:bold">in</span> cipher:
</span></span><span style="display:flex;"><span>    x = table.index(i)
</span></span><span style="display:flex;"><span>    j = (x-6)*m %26
</span></span><span style="display:flex;"><span><span style="font-style:italic">#    print j</span>
</span></span><span style="display:flex;"><span>    plainer += table[j]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>flag = <span style="font-style:italic">&#34;flag{&#34;</span>+base64.b64encode(plainer) +<span style="font-style:italic">&#34;}&#34;</span>
</span></span><span style="display:flex;"><span>print flag
</span></span></code></pre></div><p>运行脚本，得到flag：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>flag{c29yY2VyeQ==}
</span></span></code></pre></div><h2 id="0x1-汉字的秘密">
  0x1 汉字的秘密
  <a class="heading-link" href="#0x1-%e6%b1%89%e5%ad%97%e7%9a%84%e7%a7%98%e5%af%86">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h2>
<p>题目描述：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>你能看出汉字的奥秘吗？ 答案形式：flag{小写字母}
</span></span></code></pre></div><p>和汉字相关的密码，又是考察古典密码，估计是当铺密码</p>
<p>下载附件，发现附件是一个doc文件，查看附件内容：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>王壮 夫工 王中 王夫 由由井 井人 夫中 夫夫 井王 土土 夫由
</span></span><span style="display:flex;"><span>土夫 井中 士夫 王工 王人 土由 由口夫
</span></span></code></pre></div><p>看样子是当铺密码，没错了，写个脚本处理一下吧：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>dh = <span style="font-style:italic">&#39;田口由中人工大土士王夫井羊壮&#39;</span>
</span></span><span style="display:flex;"><span>ds = <span style="font-style:italic">&#39;00123455567899&#39;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>c = <span style="font-style:italic">&#39;王壮 夫工 王中 王夫 由由井 井人 夫中 夫夫 井王 土土 夫由 土夫 井中 士夫 王工 王人 土由 由口夫&#39;</span>
</span></span><span style="display:flex;"><span>s = <span style="font-style:italic">&#39;&#39;</span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">for</span> i <span style="font-weight:bold">in</span> c:
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">if</span> i <span style="font-weight:bold">in</span> dh:
</span></span><span style="display:flex;"><span>        s += ds[dh.index(i)]
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">else</span>:
</span></span><span style="display:flex;"><span>        s += <span style="font-style:italic">&#39; &#39;</span>
</span></span><span style="display:flex;"><span><span style="font-style:italic">#print(s)</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>c_list = s.split(<span style="font-style:italic">&#34; &#34;</span>)
</span></span><span style="display:flex;"><span>m = <span style="font-style:italic">&#39;&#39;</span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">for</span> i <span style="font-weight:bold">in</span> range(0,len(c_list)):
</span></span><span style="display:flex;"><span>    m += chr(int(c_list[i])+i+1)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>flag = m.lower()
</span></span><span style="display:flex;"><span>print(flag)
</span></span></code></pre></div><p>运行脚本，得到flag：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>flag{you_are_good}
</span></span></code></pre></div><hr>
<p>那什么是当铺密码呢？</p>
<p>当铺密码是一种很有意思的密码，专门用来加密数字的，不需要密钥，明文信息包含在加密后的密文中。</p>
<p>它通过一个汉字中隐藏的信息：笔画数，来将汉字和数字关联起来，将汉字定义为明文，将数字定义为密文，加密是将数字映射到对应笔画的汉字，解密是将汉字按照笔画映射回数字。</p>
<p>有很多汉字的笔画数是相同的，所以可能会有多个明文（汉字）对应同一个密文（数字），当然这个主要是看汉字笔画映射表的选择，如果映射表只准备了9个汉字，每种笔画有一个汉字对应则是一对一的，否则是一对多的。一对一的话有个缺点就是如果要加密的明文中有重复数字，比如33，转换为“飞马”比“三三”更难总结出规律，而这种没有秘钥的加密方式重要的就是隐藏自己的规律，所以一对多会更难被破译。[1]</p>
<p>当铺密码就是根据汉字的特点来设计的一种古典密码，还是挺有意思的，虽然不是很实用。</p>
<h2 id="0x2-babycrypto">
  0x2 babycrypto
  <a class="heading-link" href="#0x2-babycrypto">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h2>
<p>下载附件，查看附件内容：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span># n:0xb119849bc4523e49c6c038a509a74cda628d4ca0e4d0f28e677d57f3c3c7d0d876ef07d7581fe05a060546fedd7d061d3bc70d679b6c5dd9bc66c5bdad8f2ef898b1e785496c4989daf716a1c89d5c174da494eee7061bcb6d52cafa337fc2a7bba42c918bbd3104dff62ecc9d3704a455a6ce282de0d8129e26c840734ffd302bec5f0a66e0e6d00b5c50fa57c546cff9d7e6a978db77997082b4cb927df9847dfffef55138cb946c62c9f09b968033745b5b6868338c64819a8e92a827265f9abd409359a9471d8c3a2631b80e5b462ba42336717700998ff38536c2436e24ac19228cd2d7a909ead1a8494ff6c3a7151e888e115b68cc6a7a8c6cf8a6c005L
</span></span><span style="display:flex;"><span># e:65537
</span></span><span style="display:flex;"><span># enc:1422566584480199878714663051468143513667934216213366733442059106529451931078271460363335887054199577950679102659270179475911101747625120544429262334214483688332111552004535828182425152965223599160129610990036911146029170033592055768983427904835395850414634659565092191460875900237711597421272312032796440948509724492027247376113218678183443222364531669985128032971256792532015051829041230203814090194611041172775368357197854451201260927117792277559690205342515437625417792867692280849139537687763919269337822899746924269847694138899165820004160319118749298031065800530869562704671435709578921901495688124042302500361
</span></span><span style="display:flex;"><span># p&gt;&gt;128&lt;&lt;128:0xe4e4b390c1d201dae2c00a4669c0865cc5767bc444f5d310f3cfc75872d96feb89e556972c99ae20753e3314240a52df5dccd076a47c6b5d11b531b92d901b2b512aeb0b263bbfd624fe3d52e5e238beeb581ebe012b2f176a4ffd1e0d2aa8c4d3a2656573b727d4d3136513a931428b00000000000000000000000000000000L
</span></span></code></pre></div><p>RSA题目，考察的应该是p的高位泄露，应该是针对p的高位泄露进行设计的攻击算法来进行求解的。经查询发现，coppersmith算法应该是就是解决p高位泄露问题的解密算法，但是这个算法需要使用的开源数学工具sagemath。这里采用sagemath程序解决：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>n = 0xb119849bc4523e49c6c038a509a74cda628d4ca0e4d0f28e677d57f3c3c7d0d876ef07d7581fe05a060546fedd7d061d3bc70d679b6c5dd9bc66c5bdad8f2ef898b1e785496c4989daf716a1c89d5c174da494eee7061bcb6d52cafa337fc2a7bba42c918bbd3104dff62ecc9d3704a455a6ce282de0d8129e26c840734ffd302bec5f0a66e0e6d00b5c50fa57c546cff9d7e6a978db77997082b4cb927df9847dfffef55138cb946c62c9f09b968033745b5b6868338c64819a8e92a827265f9abd409359a9471d8c3a2631b80e5b462ba42336717700998ff38536c2436e24ac19228cd2d7a909ead1a8494ff6c3a7151e888e115b68cc6a7a8c6cf8a6c005L
</span></span><span style="display:flex;"><span>p_fake = 0xe4e4b390c1d201dae2c00a4669c0865cc5767bc444f5d310f3cfc75872d96feb89e556972c99ae20753e3314240a52df5dccd076a47c6b5d11b531b92d901b2b512aeb0b263bbfd624fe3d52e5e238beeb581ebe012b2f176a4ffd1e0d2aa8c4d3a2656573b727d4d3136513a931428b00000000000000000000000000000000L
</span></span><span style="display:flex;"><span>pbits = 1024
</span></span><span style="display:flex;"><span>kbits = 128
</span></span><span style="display:flex;"><span>pbar = p_fake &amp; (2^pbits-2^kbits)
</span></span><span style="display:flex;"><span>print(<span style="font-style:italic">&#34;upper </span><span style="font-weight:bold;font-style:italic">%d</span><span style="font-style:italic"> bits (of </span><span style="font-weight:bold;font-style:italic">%d</span><span style="font-style:italic"> bits) is given&#34;</span> % (pbits-kbits, pbits))
</span></span><span style="display:flex;"><span>PR.&lt;x&gt; = PolynomialRing(Zmod(n))
</span></span><span style="display:flex;"><span>f = x + pbar
</span></span><span style="display:flex;"><span>x0 = f.small_roots(X=2^kbits, beta=0.4)[0]
</span></span><span style="display:flex;"><span>print(hex(int(x0 + pbar)))
</span></span></code></pre></div><p>使用sagemath运行可以得到p的数值：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>0xe4e4b390c1d201dae2c00a4669c0865cc5767bc444f5d310f3cfc75872d96feb89e556972c99ae20753e3314240a52df5dccd076a47c6b5d11b531b92d901b2b512aeb0b263bbfd624fe3d52e5e238beeb581ebe012b2f176a4ffd1e0d2aa8c4d3a2656573b727d4d3136513a931428b92826225b6d0e735440b613a8336ffa3
</span></span></code></pre></div><p>然后再使用一常规的RSA脚本进行求解：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="font-weight:bold">import</span> <span style="font-weight:bold">libnum</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>n = 0xb119849bc4523e49c6c038a509a74cda628d4ca0e4d0f28e677d57f3c3c7d0d876ef07d7581fe05a060546fedd7d061d3bc70d679b6c5dd9bc66c5bdad8f2ef898b1e785496c4989daf716a1c89d5c174da494eee7061bcb6d52cafa337fc2a7bba42c918bbd3104dff62ecc9d3704a455a6ce282de0d8129e26c840734ffd302bec5f0a66e0e6d00b5c50fa57c546cff9d7e6a978db77997082b4cb927df9847dfffef55138cb946c62c9f09b968033745b5b6868338c64819a8e92a827265f9abd409359a9471d8c3a2631b80e5b462ba42336717700998ff38536c2436e24ac19228cd2d7a909ead1a8494ff6c3a7151e888e115b68cc6a7a8c6cf8a6c005L
</span></span><span style="display:flex;"><span>e = 65537
</span></span><span style="display:flex;"><span>c = 1422566584480199878714663051468143513667934216213366733442059106529451931078271460363335887054199577950679102659270179475911101747625120544429262334214483688332111552004535828182425152965223599160129610990036911146029170033592055768983427904835395850414634659565092191460875900237711597421272312032796440948509724492027247376113218678183443222364531669985128032971256792532015051829041230203814090194611041172775368357197854451201260927117792277559690205342515437625417792867692280849139537687763919269337822899746924269847694138899165820004160319118749298031065800530869562704671435709578921901495688124042302500361
</span></span><span style="display:flex;"><span>p = 0xe4e4b390c1d201dae2c00a4669c0865cc5767bc444f5d310f3cfc75872d96feb89e556972c99ae20753e3314240a52df5dccd076a47c6b5d11b531b92d901b2b512aeb0b263bbfd624fe3d52e5e238beeb581ebe012b2f176a4ffd1e0d2aa8c4d3a2656573b727d4d3136513a931428b92826225b6d0e735440b613a8336ffa3
</span></span><span style="display:flex;"><span>q = n // p
</span></span><span style="display:flex;"><span>phi = (p-1)*(q-1)
</span></span><span style="display:flex;"><span>d = libnum.invmod(e,phi)
</span></span><span style="display:flex;"><span>m = pow(c,d,n)
</span></span><span style="display:flex;"><span>flag = libnum.n2s(m)
</span></span><span style="display:flex;"><span>print flag
</span></span></code></pre></div><p>运行脚本，得到flag：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>flag{3d0914a1-1e97-4822-a745-c7e20c5179b9}
</span></span></code></pre></div><h2 id="0x3-backdoor">
  0x3 Backdoor
  <a class="heading-link" href="#0x3-backdoor">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h2>
<p>查看题目描述：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>p=k*M+(65537**a %M)
</span></span></code></pre></div><p>根据题目描述可以联想到ROCA漏洞，可以从论文中清晰地看到：</p>
<p><a href="/images/GKCTF2020-Crypto_writeup/image-12.png"><img src="/images/GKCTF2020-Crypto_writeup/image-12.png" alt="img"></a></p>
<p>正好符合这个题目的hint，这个题目的考察要点应该就是<a href="https://crocs.fi.muni.cz/public/papers/rsa_ccs17">ROCA的CVE漏洞</a>。这个CVE的利用再GitHub上面有现成的轮子，进行稍微修改一下就可以使用，这里给出解题的sagemath exp：[2]</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>param = 
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  512: {
</span></span><span style="display:flex;"><span>    <span style="font-style:italic">&#34;n&#34;</span>: 39,
</span></span><span style="display:flex;"><span>    <span style="font-style:italic">&#34;a_max&#34;</span>: 62,
</span></span><span style="display:flex;"><span>    <span style="font-style:italic">&#34;k_max&#34;</span>: 37,
</span></span><span style="display:flex;"><span>    <span style="font-style:italic">&#34;M&#34;</span>: 0x924cba6ae99dfa084537facc54948df0c23da044d8cabe0edd75bc6,
</span></span><span style="display:flex;"><span>    <span style="font-style:italic">&#34;M_prime&#34;</span>: 0x1b3e6c9433a7735fa5fc479ffe4027e13bea,
</span></span><span style="display:flex;"><span>    <span style="font-style:italic">&#34;m&#34;</span>: 5,
</span></span><span style="display:flex;"><span>    <span style="font-style:italic">&#34;t&#34;</span>: 6,
</span></span><span style="display:flex;"><span>    <span style="font-style:italic">&#34;c_a&#34;</span>: 0x80000
</span></span><span style="display:flex;"><span>  },
</span></span><span style="display:flex;"><span>  1024: {
</span></span><span style="display:flex;"><span>    <span style="font-style:italic">&#34;n&#34;</span>: 71,
</span></span><span style="display:flex;"><span>    <span style="font-style:italic">&#34;a_max&#34;</span>: 134,
</span></span><span style="display:flex;"><span>    <span style="font-style:italic">&#34;k_max&#34;</span>: 37,
</span></span><span style="display:flex;"><span>    <span style="font-style:italic">&#34;M&#34;</span>: 0x7923ba25d1263232812ac930e9683ac0b02180c32bae1d77aa950c4a18a4e660db8cc90384a394940593408f192de1a05e1b61673ac499416088382,
</span></span><span style="display:flex;"><span>    <span style="font-style:italic">&#34;M_prime&#34;</span>: 0x24683144f41188c2b1d6a217f81f12888e4e6513c43f3f60e72af8bd9728807483425d1e,
</span></span><span style="display:flex;"><span>    <span style="font-style:italic">&#34;m&#34;</span>: 4,
</span></span><span style="display:flex;"><span>    <span style="font-style:italic">&#34;t&#34;</span>: 5,
</span></span><span style="display:flex;"><span>    <span style="font-style:italic">&#34;c_a&#34;</span>: 0x40000000
</span></span><span style="display:flex;"><span>  },
</span></span><span style="display:flex;"><span>  2048: {
</span></span><span style="display:flex;"><span>    <span style="font-style:italic">&#34;n&#34;</span>: 126,
</span></span><span style="display:flex;"><span>    <span style="font-style:italic">&#34;a_max&#34;</span>: 434,
</span></span><span style="display:flex;"><span>    <span style="font-style:italic">&#34;k_max&#34;</span>: 53,
</span></span><span style="display:flex;"><span>    <span style="font-style:italic">&#34;M&#34;</span>: 0x7cda79f57f60a9b65478052f383ad7dadb714b4f4ac069997c7ff23d34d075fca08fdf20f95fbc5f0a981d65c3a3ee7ff74d769da52e948d6b0270dd736ef61fa99a54f80fb22091b055885dc22b9f17562778dfb2aeac87f51de339f71731d207c0af3244d35129feba028a48402247f4ba1d2b6d0755baff6,
</span></span><span style="display:flex;"><span>    <span style="font-style:italic">&#34;M_prime&#34;</span>: 0x16928dc3e47b44daf289a60e80e1fc6bd7648d7ef60d1890f3e0a9455efe0abdb7a748131413cebd2e36a76a355c1b664be462e115ac330f9c13344f8f3d1034a02c23396e6,
</span></span><span style="display:flex;"><span>    <span style="font-style:italic">&#34;m&#34;</span>: 7,
</span></span><span style="display:flex;"><span>    <span style="font-style:italic">&#34;t&#34;</span>: 8,
</span></span><span style="display:flex;"><span>    <span style="font-style:italic">&#34;c_a&#34;</span>: 0x400000000
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-style:italic"># https://github.com/mimoo/RSA-and-LLL-attacks/blob/master/coppersmith.sage</span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">def</span> coppersmith_howgrave_univariate(pol, N, beta, mm, tt, XX):
</span></span><span style="display:flex;"><span>    <span style="font-style:italic">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="font-style:italic">    Coppersmith revisited by Howgrave-Graham
</span></span></span><span style="display:flex;"><span><span style="font-style:italic">    
</span></span></span><span style="display:flex;"><span><span style="font-style:italic">    finds a solution if:
</span></span></span><span style="display:flex;"><span><span style="font-style:italic">    * b|N, b &gt;= N^beta , 0 &lt; beta &lt;= 1
</span></span></span><span style="display:flex;"><span><span style="font-style:italic">    * |x| &lt; XX
</span></span></span><span style="display:flex;"><span><span style="font-style:italic">    &#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="font-style:italic">#</span>
</span></span><span style="display:flex;"><span>    <span style="font-style:italic"># init</span>
</span></span><span style="display:flex;"><span>    <span style="font-style:italic">#</span>
</span></span><span style="display:flex;"><span>    dd = pol.degree()
</span></span><span style="display:flex;"><span>    nn = dd * mm + tt
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="font-style:italic">#</span>
</span></span><span style="display:flex;"><span>    <span style="font-style:italic"># checks</span>
</span></span><span style="display:flex;"><span>    <span style="font-style:italic">#</span>
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">if</span> <span style="font-weight:bold">not</span> 0 &lt; beta &lt;= 1 :
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">raise</span> <span style="font-weight:bold">ValueError</span>(<span style="font-style:italic">&#34;beta should belongs in (0, 1]&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">if</span> <span style="font-weight:bold">not</span> pol.is_monic():
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">raise</span> <span style="font-weight:bold">ArithmeticError</span>(<span style="font-style:italic">&#34;Polynomial must be monic.&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="font-style:italic">#</span>
</span></span><span style="display:flex;"><span>    <span style="font-style:italic"># Coppersmith revisited algo for univariate</span>
</span></span><span style="display:flex;"><span>    <span style="font-style:italic">#</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="font-style:italic"># change ring of pol and x</span>
</span></span><span style="display:flex;"><span>    polZ = pol.change_ring(ZZ)
</span></span><span style="display:flex;"><span>    x = polZ.parent().gen()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="font-style:italic"># compute polynomials</span>
</span></span><span style="display:flex;"><span>    gg = []
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">for</span> ii <span style="font-weight:bold">in</span> range(mm):
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">for</span> jj <span style="font-weight:bold">in</span> range(dd):
</span></span><span style="display:flex;"><span>            gg.append((x * XX)**jj * N**(mm - ii) * polZ(x * XX)**ii)
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">for</span> ii <span style="font-weight:bold">in</span> range(tt):
</span></span><span style="display:flex;"><span>        gg.append((x * XX)**ii * polZ(x * XX)**mm)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="font-style:italic"># construct lattice B</span>
</span></span><span style="display:flex;"><span>    BB = Matrix(ZZ, nn)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">for</span> ii <span style="font-weight:bold">in</span> range(nn):
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">for</span> jj <span style="font-weight:bold">in</span> range(ii+1):
</span></span><span style="display:flex;"><span>            BB[ii, jj] = gg[ii][jj]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="font-style:italic"># LLL</span>
</span></span><span style="display:flex;"><span>    BB = BB.LLL(early_red=<span style="font-weight:bold">True</span>, use_siegel=<span style="font-weight:bold">True</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="font-style:italic"># transform shortest vector in polynomial    </span>
</span></span><span style="display:flex;"><span>    new_pol = 0
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">for</span> ii <span style="font-weight:bold">in</span> range(nn):
</span></span><span style="display:flex;"><span>        new_pol += x**ii * BB[0, ii] / XX**ii
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="font-style:italic"># factor polynomial</span>
</span></span><span style="display:flex;"><span>    potential_roots = new_pol.roots()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> [i[0] <span style="font-weight:bold">for</span> i <span style="font-weight:bold">in</span> potential_roots]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-style:italic"># Top level of the attack, feeds the queue for the workers</span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">def</span> roca(N):
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="font-style:italic"># Key is not always of perfect size, infer from size</span>
</span></span><span style="display:flex;"><span>  keylength = int(log(N, 2))
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold">if</span> keylength &lt; 1000 :
</span></span><span style="display:flex;"><span>    keylength = 512
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold">elif</span>  keylength &lt; 2000 :
</span></span><span style="display:flex;"><span>    keylength = 1024 
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold">elif</span> keylength &lt; 4000 :
</span></span><span style="display:flex;"><span>    keylength = 2048 
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold">else</span>:
</span></span><span style="display:flex;"><span>    keylength = 4096 
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="font-style:italic"># bruteforce</span>
</span></span><span style="display:flex;"><span>  M_prime = param[keylength][<span style="font-style:italic">&#39;M_prime&#39;</span>]
</span></span><span style="display:flex;"><span>  c_prime = discrete_log(N, Mod(65537, M_prime))
</span></span><span style="display:flex;"><span>  ord_prime = Zmod(M_prime)(65537).multiplicative_order()
</span></span><span style="display:flex;"><span>  top = (c_prime + ord_prime)/2
</span></span><span style="display:flex;"><span>  beta = 0.5 
</span></span><span style="display:flex;"><span>  mm = param[keylength][<span style="font-style:italic">&#39;m&#39;</span>]
</span></span><span style="display:flex;"><span>  tt = param[keylength][<span style="font-style:italic">&#39;t&#39;</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  XX = int((2*pow(N, beta)) / M_prime) 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="font-style:italic"># Bruteforce until p, q are found</span>
</span></span><span style="display:flex;"><span>  a_prime = floor(c_prime/2)
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold">while</span> a_prime &lt; top:
</span></span><span style="display:flex;"><span>      
</span></span><span style="display:flex;"><span>      <span style="font-style:italic"># Construct polynomial</span>
</span></span><span style="display:flex;"><span>      m_inv = int(inverse_mod(M_prime, N))
</span></span><span style="display:flex;"><span>      k_tmp = int(pow(65537, a_prime, M_prime))
</span></span><span style="display:flex;"><span>      known_part_pol = int(k_tmp * m_inv)
</span></span><span style="display:flex;"><span>      F = PolynomialRing(Zmod(N), implementation=<span style="font-style:italic">&#39;NTL&#39;</span>, names=(<span style="font-style:italic">&#39;x&#39;</span>,))
</span></span><span style="display:flex;"><span>      (x,) = F._first_ngens(1)
</span></span><span style="display:flex;"><span>      pol = x + known_part_pol
</span></span><span style="display:flex;"><span>      
</span></span><span style="display:flex;"><span>      <span style="font-style:italic"># Get roots of polynomial using coppersmith</span>
</span></span><span style="display:flex;"><span>      roots = coppersmith_howgrave_univariate(pol, N, beta, mm, tt, XX)
</span></span><span style="display:flex;"><span>     
</span></span><span style="display:flex;"><span>      <span style="font-style:italic"># Check if roots are p, q</span>
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold">for</span> root <span style="font-weight:bold">in</span> roots:
</span></span><span style="display:flex;"><span>        factor1 = k_tmp + abs(root) * M_prime
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">if</span> mod(N, factor1) == 0:
</span></span><span style="display:flex;"><span>          factor2 = N // factor1
</span></span><span style="display:flex;"><span>          <span style="font-weight:bold">return</span> int(factor1), int(factor2)
</span></span><span style="display:flex;"><span>      a_prime += 1
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">from</span> <span style="font-weight:bold">Crypto.Util.number</span> <span style="font-weight:bold">import</span> *
</span></span><span style="display:flex;"><span><span style="font-weight:bold">from</span> <span style="font-weight:bold">Crypto.PublicKey</span> <span style="font-weight:bold">import</span> RSA
</span></span><span style="display:flex;"><span><span style="font-weight:bold">import</span> <span style="font-weight:bold">base64</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">with</span> open(<span style="font-style:italic">&#39;./pub.pem&#39;</span>, <span style="font-style:italic">&#39;r&#39;</span>) <span style="font-weight:bold">as</span> f:
</span></span><span style="display:flex;"><span>    key = RSA.import_key(f.read())
</span></span><span style="display:flex;"><span>    e = key.e
</span></span><span style="display:flex;"><span>    n = key.n
</span></span><span style="display:flex;"><span>print(n)
</span></span><span style="display:flex;"><span><span style="font-weight:bold">with</span> open(<span style="font-style:italic">&#39;flag.enc&#39;</span>, <span style="font-style:italic">&#39;r&#39;</span>) <span style="font-weight:bold">as</span> f:
</span></span><span style="display:flex;"><span>    c = base64.b64decode(f.read())
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>N = n
</span></span><span style="display:flex;"><span>print (<span style="font-style:italic">&#34;[+] Factoring </span><span style="font-weight:bold;font-style:italic">%i</span><span style="font-style:italic">&#34;</span> % N)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>factor1, factor2 = roca(N)
</span></span><span style="display:flex;"><span>q = factor1
</span></span><span style="display:flex;"><span>p = factor2
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>print (<span style="font-style:italic">&#34;[+] Found factors of N:&#34;</span>)
</span></span><span style="display:flex;"><span>print (<span style="font-style:italic">&#34;[+] p =&#34;</span> , factor1)
</span></span><span style="display:flex;"><span>print (<span style="font-style:italic">&#34;[+] q =&#34;</span> , factor2)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">assert</span>(p * q == n)
</span></span><span style="display:flex;"><span>d = inverse(e, (q - 1) * (p - 1))
</span></span><span style="display:flex;"><span>c = bytes_to_long(bytes.fromhex(str(c)[2:-1]))
</span></span><span style="display:flex;"><span>print(long_to_bytes(pow(c, d, n)))
</span></span></code></pre></div><p>使用sagemath运行得到flag：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>flag{760958c9-cca9-458b-9cbe-ea07aa1668e4}
</span></span></code></pre></div><h2 id="参考">
  参考：
  <a class="heading-link" href="#%e5%8f%82%e8%80%83">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h2>
<ol>
<li><a href="https://www.cnblogs.com/cc11001100/p/9357263.html#:~:text=%E5%BD%93%E9%93%BA%E5%AF%86%E7%A0%81%E6%98%AF%E4%B8%80%E7%A7%8D%E5%BE%88,%E5%8A%A0%E5%AF%86%E5%90%8E%E7%9A%84%E5%AF%86%E6%96%87%E4%B8%AD%E3%80%82">当铺密码-博客园</a></li>
<li><a href="https://blog.chrisyy.top/2020/05/24/gkctf/">GKCTF2020 Crypto Writeup- Chrisyy&rsquo;s blog</a></li>
</ol>

      </div>


      <footer>
        


        <div id="disqus_thread"></div>
<script type="application/javascript">
    window.disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "yourdiscussshortname" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
        
        
      </footer>
    </article>

    
  </section>

    </div>

    <footer class="footer">
  <section class="container">
    ©
    
      2019 -
    
    2022
     OrcasCode 
    ·
    
    Powered by <a href="https://gohugo.io/">Hugo</a> & <a href="https://github.com/luizdepra/hugo-coder/">Coder</a>.
    
  </section>
</footer>

  </main>

  
  
  <script src="/js/coder.min.236049395dc3682fb2719640872958e12f1f24067bb09c327b233e6290c7edac.js" integrity="sha256-I2BJOV3DaC&#43;ycZZAhylY4S8fJAZ7sJwyeyM&#43;YpDH7aw="></script>
  

  

  

  

  

  

  

  

  

  
</body>

</html>
