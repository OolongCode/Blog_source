<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="color-scheme" content="light dark">




<meta name="author" content="OrcasCode">
<meta name="description" content="OtterCTF 2018 Memory Forensic Reappearance想学习并练习下电子取证技术，经过网络上的一番搜索发现OtterCTF的取证题目非常有意思，这次尝试练习下内存取证的题目顺便学习下内存取证的相关内容和技能点。内存取证主要使用的工具是Volatility，githu上面有相关项目。Volatility有两个版本分别是用python2和python3进行构建的，目前主要的组件还是以python2为主。 Volatility项目地址：https://github.com/volatilityfoundation/volatility Volatility3项目地址：https://github.com/volatilityfoundation/volatility3
环境配置：Kali Linux 2022 工具配置：volatility &#43; mimikatz
Info题目附件就一个镜像，先查看下镜像的指纹数据：
5b3d8a9f9c96581a821c19b71dd6aa80dd299fc674b818f443f3a6fb5495a872 OtterCTF.vmem 使用vol简单查看下镜像信息数据，查看数据的指令：
vol.py -f OtterCTF.vmem imageinfo 说明
vol.py volatility程序 -f OtterCTF.vmem 加载OtterCTF.vmem内存镜像文件 imageinfo 查看内存镜像的基本信息 得到如下信息：
可以看到大致的镜像系统是Win7系统
What the password?查看题目描述：
you got a sample of rick&#39;s PC&#39;s memory. can you get his user password? 要得到用户名的密码，先获取到hash数据，使用获取hash的指令：
vol.py -f OtterCTF.vmem --profile=Win7SP1x64 hashdump --profile=Win7SP1x64 设置配置为Win7SP1x64配置 hashdump 从内存中dump出密码的hash信息 得到hash信息：
对于这种hash信息可以使用mimikatz插件，或者使用hashcat也可以，这里使用mimikatz进行获取
使用如下指令使用mimikatz插件进行获取：
vol.py -f OtterCTF.vmem --profile=Win7SP1x64 mimikatz 得到如下信息：">
<meta name="keywords" content="blog,developer,personal">

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="OtterCTF 2018 内存取证复现"/>
<meta name="twitter:description" content="OtterCTF 2018 Memory Forensic Reappearance想学习并练习下电子取证技术，经过网络上的一番搜索发现OtterCTF的取证题目非常有意思，这次尝试练习下内存取证的题目顺便学习下内存取证的相关内容和技能点。内存取证主要使用的工具是Volatility，githu上面有相关项目。Volatility有两个版本分别是用python2和python3进行构建的，目前主要的组件还是以python2为主。 Volatility项目地址：https://github.com/volatilityfoundation/volatility Volatility3项目地址：https://github.com/volatilityfoundation/volatility3
环境配置：Kali Linux 2022 工具配置：volatility &#43; mimikatz
Info题目附件就一个镜像，先查看下镜像的指纹数据：
5b3d8a9f9c96581a821c19b71dd6aa80dd299fc674b818f443f3a6fb5495a872 OtterCTF.vmem 使用vol简单查看下镜像信息数据，查看数据的指令：
vol.py -f OtterCTF.vmem imageinfo 说明
vol.py volatility程序 -f OtterCTF.vmem 加载OtterCTF.vmem内存镜像文件 imageinfo 查看内存镜像的基本信息 得到如下信息：
可以看到大致的镜像系统是Win7系统
What the password?查看题目描述：
you got a sample of rick&#39;s PC&#39;s memory. can you get his user password? 要得到用户名的密码，先获取到hash数据，使用获取hash的指令：
vol.py -f OtterCTF.vmem --profile=Win7SP1x64 hashdump --profile=Win7SP1x64 设置配置为Win7SP1x64配置 hashdump 从内存中dump出密码的hash信息 得到hash信息：
对于这种hash信息可以使用mimikatz插件，或者使用hashcat也可以，这里使用mimikatz进行获取
使用如下指令使用mimikatz插件进行获取：
vol.py -f OtterCTF.vmem --profile=Win7SP1x64 mimikatz 得到如下信息："/>

<meta property="og:title" content="OtterCTF 2018 内存取证复现" />
<meta property="og:description" content="OtterCTF 2018 Memory Forensic Reappearance想学习并练习下电子取证技术，经过网络上的一番搜索发现OtterCTF的取证题目非常有意思，这次尝试练习下内存取证的题目顺便学习下内存取证的相关内容和技能点。内存取证主要使用的工具是Volatility，githu上面有相关项目。Volatility有两个版本分别是用python2和python3进行构建的，目前主要的组件还是以python2为主。 Volatility项目地址：https://github.com/volatilityfoundation/volatility Volatility3项目地址：https://github.com/volatilityfoundation/volatility3
环境配置：Kali Linux 2022 工具配置：volatility &#43; mimikatz
Info题目附件就一个镜像，先查看下镜像的指纹数据：
5b3d8a9f9c96581a821c19b71dd6aa80dd299fc674b818f443f3a6fb5495a872 OtterCTF.vmem 使用vol简单查看下镜像信息数据，查看数据的指令：
vol.py -f OtterCTF.vmem imageinfo 说明
vol.py volatility程序 -f OtterCTF.vmem 加载OtterCTF.vmem内存镜像文件 imageinfo 查看内存镜像的基本信息 得到如下信息：
可以看到大致的镜像系统是Win7系统
What the password?查看题目描述：
you got a sample of rick&#39;s PC&#39;s memory. can you get his user password? 要得到用户名的密码，先获取到hash数据，使用获取hash的指令：
vol.py -f OtterCTF.vmem --profile=Win7SP1x64 hashdump --profile=Win7SP1x64 设置配置为Win7SP1x64配置 hashdump 从内存中dump出密码的hash信息 得到hash信息：
对于这种hash信息可以使用mimikatz插件，或者使用hashcat也可以，这里使用mimikatz进行获取
使用如下指令使用mimikatz插件进行获取：
vol.py -f OtterCTF.vmem --profile=Win7SP1x64 mimikatz 得到如下信息：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.codetea.top/posts/otterctf_2018_memory_forensic_writeup/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-10-04T23:18:37+08:00" />
<meta property="article:modified_time" content="2022-10-04T23:18:37+08:00" />




  <title>OPdbg</title>

  
  <link rel="canonical" href="https://www.codetea.top/posts/otterctf_2018_memory_forensic_writeup/">
  

  <link rel="preload" href="/fonts/forkawesome-webfont.woff2?v=1.2.0" as="font" type="font/woff2" crossorigin>


  
  
  <link rel="stylesheet" href="/css/coder.min.6b1a4fbc48955b72aea7913e43fabeb45e8bc120da5aa41b598dd33adcac4b59.css" integrity="sha256-axpPvEiVW3Kup5E&#43;Q/q&#43;tF6LwSDaWqQbWY3TOtysS1k=" crossorigin="anonymous" media="screen" />





  
  
    
    
    <link rel="stylesheet" href="/css/coder-dark.min.39e41a7f16bdf8cb16e43cae7d714fa1016f1d2d2898a5b3f27f42c9979204e2.css" integrity="sha256-OeQafxa9&#43;MsW5DyufXFPoQFvHS0omKWz8n9CyZeSBOI=" crossorigin="anonymous" media="screen" />
  



   





  <link rel="icon" type="image/png" href="/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="/favicon-16x16.png" sizes="16x16">

<link rel="apple-touch-icon" href="/images/apple-touch-icon.png">
<link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

<link rel="manifest" href="/site.webmanifest">
<link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#5bbad5">


  

  <meta name="generator" content="Hugo 0.101.0" />


  

<link href="https://cdn.bootcdn.net/ajax/libs/highlight.js/11.5.1/styles/atom-one-dark-reasonable.min.css" rel="stylesheet">
<script src="https://cdn.bootcdn.net/ajax/libs/highlight.js/11.5.1/highlight.min.js"></script>
<script src="https://cdn.bootcdn.net/ajax/libs/highlight.js/11.5.1/languages/armasm.min.js"></script>
<script src="https://cdn.bootcdn.net/ajax/libs/highlight.js/11.5.1/languages/mipsasm.min.js"></script>
<script src="https://cdn.bootcdn.net/ajax/libs/highlight.js/11.5.1/languages/wasm.min.js"></script>
<script src="https://cdn.bootcdn.net/ajax/libs/highlight.js/11.5.1/languages/x86asm.min.js"></script>
<script>hljs.highlightAll();</script>
</head>







<body class="preload-transitions colorscheme-auto">
  
<div class="float-container">
    <a id="dark-mode-toggle" class="colorscheme-toggle">
        <i class="fa fa-adjust fa-fw" aria-hidden="true"></i>
    </a>
</div>


  <main class="wrapper">
    <nav class="navigation">
  <section class="container">
    <a class="navigation-title" href="/">
      OPdbg
    </a>
    
      <input type="checkbox" id="menu-toggle" />
      <label class="menu-button float-right" for="menu-toggle">
        <i class="fa fa-bars fa-fw" aria-hidden="true"></i>
      </label>
      <ul class="navigation-list">
        
          
            <li class="navigation-item">
              <a class="navigation-link" href="/about/">About</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="/posts/">Posts</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="/categories/">Categories</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="/tags/">Tags</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="/link/">Link</a>
            </li>
          
        
        
      </ul>
    
  </section>
</nav>


    <div class="content">
      
  <section class="container post">
    <article>
      <header>
        <div class="post-title">
          <h1 class="title">
            <a class="title-link" href="https://www.codetea.top/posts/otterctf_2018_memory_forensic_writeup/">
              OtterCTF 2018 内存取证复现
            </a>
          </h1>
        </div>
        <div class="post-meta">
          <div class="date">
            <span class="posted-on">
              <i class="fa fa-calendar" aria-hidden="true"></i>
              <time datetime="2022-10-04T23:18:37&#43;08:00">
                October 4, 2022
              </time>
            </span>
            <span class="reading-time">
              <i class="fa fa-clock-o" aria-hidden="true"></i>
              4-minute read
            </span>
          </div>
          
          <div class="categories">
  <i class="fa fa-folder" aria-hidden="true"></i>
    <a href="/categories/challange/">challange</a></div>

          <div class="tags">
  <i class="fa fa-tag" aria-hidden="true"></i>
    <span class="tag">
      <a href="/tags/ctf/">ctf</a>
    </span>
      <span class="separator">•</span>
    <span class="tag">
      <a href="/tags/forensics/">Forensics</a>
    </span>
      <span class="separator">•</span>
    <span class="tag">
      <a href="/tags/writeup/">writeup</a>
    </span></div>

        </div>
      </header>

      <div>
        
        <h1 id="otterctf-2018-memory-forensic-reappearance">
  OtterCTF 2018 Memory Forensic Reappearance
  <a class="heading-link" href="#otterctf-2018-memory-forensic-reappearance">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h1>
<p>想学习并练习下电子取证技术，经过网络上的一番搜索发现OtterCTF的取证题目非常有意思，这次尝试练习下内存取证的题目顺便学习下内存取证的相关内容和技能点。内存取证主要使用的工具是Volatility，githu上面有相关项目。Volatility有两个版本分别是用python2和python3进行构建的，目前主要的组件还是以python2为主。
Volatility项目地址：<a href="https://github.com/volatilityfoundation/volatility">https://github.com/volatilityfoundation/volatility</a>
Volatility3项目地址：<a href="https://github.com/volatilityfoundation/volatility3">https://github.com/volatilityfoundation/volatility3</a></p>
<p>环境配置：Kali Linux 2022
工具配置：volatility + mimikatz</p>
<h2 id="info">
  Info
  <a class="heading-link" href="#info">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h2>
<p>题目附件就一个镜像，先查看下镜像的指纹数据：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>5b3d8a9f9c96581a821c19b71dd6aa80dd299fc674b818f443f3a6fb5495a872  OtterCTF.vmem
</span></span></code></pre></div><p>使用vol简单查看下镜像信息数据，查看数据的指令：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>vol.py -f OtterCTF.vmem imageinfo
</span></span></code></pre></div><blockquote>
<p><strong>说明</strong></p>
<ul>
<li><code>vol.py</code> volatility程序</li>
<li><code>-f OtterCTF.vmem</code>  加载<code>OtterCTF.vmem</code>内存镜像文件</li>
<li><code>imageinfo</code> 查看内存镜像的基本信息</li>
</ul>
</blockquote>
<p>得到如下信息：</p>
<p><img src="/images/OtterCTF_2018_Memory_Forensic_writeup/image-20221002204848160.png" alt="image-20221002204848160"></p>
<p>可以看到大致的镜像系统是Win7系统</p>
<h2 id="what-the-password">
  What the password?
  <a class="heading-link" href="#what-the-password">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h2>
<p>查看题目描述：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>you got a sample of rick&#39;s PC&#39;s memory. can you get his user password?
</span></span></code></pre></div><p>要得到用户名的密码，先获取到hash数据，使用获取hash的指令：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>vol.py -f OtterCTF.vmem --profile=Win7SP1x64 hashdump  
</span></span></code></pre></div><blockquote>
<ul>
<li><code>--profile=Win7SP1x64</code> 设置配置为<code>Win7SP1x64</code>配置</li>
<li><code>hashdump</code> 从内存中dump出密码的hash信息</li>
</ul>
</blockquote>
<p>得到hash信息：</p>
<p><img src="/images/OtterCTF_2018_Memory_Forensic_writeup/image-20221002212051508.png" alt="image-20221002212051508"></p>
<p>对于这种hash信息可以使用mimikatz插件，或者使用hashcat也可以，这里使用mimikatz进行获取</p>
<p>使用如下指令使用mimikatz插件进行获取：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>vol.py -f OtterCTF.vmem --profile=Win7SP1x64 mimikatz
</span></span></code></pre></div><p>得到如下信息：</p>
<p><img src="/images/OtterCTF_2018_Memory_Forensic_writeup/image-20221002214545148.png" alt="image-20221002214545148"></p>
<p>已经获取到了密码信息，提交flag，攻破此题：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>CTF{MortyIsReallyAnOtter}
</span></span></code></pre></div><h2 id="general-info">
  General Info
  <a class="heading-link" href="#general-info">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h2>
<p>查看题目描述：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>Let&#39;s start easy - whats the PC&#39;s name and IP address?
</span></span></code></pre></div><p>需要获取PC’s name和IP， PC的名字已经很明确了，应该就是刚刚获取密码信息得到的<code>WIN-LO6FAF3DTFE</code></p>
<p>下面需要获取的应该就是IP地址，使用网络扫描指令应该可以获取到相应的信息：</p>
<p><img src="/images/OtterCTF_2018_Memory_Forensic_writeup/image-20221003001348636.png" alt="image-20221003001348636"></p>
<p>可以看出IP地址应该是：<code>192.168.202.131</code></p>
<p>根据题目要求，flag应该是：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>CTF{WIN-LO6FAF3DTFE}
</span></span><span style="display:flex;"><span>CTF{192.168.202.131}
</span></span></code></pre></div><h2 id="play-time">
  Play Time
  <a class="heading-link" href="#play-time">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h2>
<p>查看题目描述：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>Rick just loves to play some good old videogames.
</span></span><span style="display:flex;"><span>can you tell which game is he playing?
</span></span><span style="display:flex;"><span>whats the IP address of the server?
</span></span></code></pre></div><p>玩游戏肯定会有进程的存储在内存中，扫描下进程情况，使用如下指令进行查看：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>vol.py -f OtterCTF.vmem --profile=Win7SP1x64 psscan
</span></span></code></pre></div><p>得到如下信息：</p>
<p><img src="/images/OtterCTF_2018_Memory_Forensic_writeup/image-20221003002817020.png" alt="image-20221003002817020"></p>
<p>可以发现到了一个不熟悉的进程，猜测这个进程是游戏进程，也就是游戏名称是<code>LunarMS.exe</code></p>
<p>再使用<code>netscan</code>查看下网络通信信息：</p>
<p><img src="/images/OtterCTF_2018_Memory_Forensic_writeup/image-20221003003940157.png" alt="image-20221003003940157"></p>
<p>可以发现一个ip地址，应该是游戏下载的ip地址，可以得到flag：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>CTF{LunarMS.exe}
</span></span><span style="display:flex;"><span>CTF{77.102.199.102}
</span></span></code></pre></div><h2 id="name-game">
  Name Game
  <a class="heading-link" href="#name-game">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h2>
<p>查看题目描述：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>We know that the account was logged in to a channel called Lunar-3. what is the account name?
</span></span></code></pre></div><p>应该需要找到游戏的用户名，应该存储在游戏的内存中，尝试将游戏进程进行dump来获取到游戏进程的内存信息</p>
<p>vol程序进行内存dump的指令如下：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>vol.py -f OtterCTF.vmem --profile=Win7SP1x64 memdump -p 708 -D ./
</span></span></code></pre></div><blockquote>
<p><strong>说明</strong></p>
<ul>
<li><code>memdump</code> 内存dump的命令</li>
<li><code>-p 708</code> 指定PID号708的进程</li>
<li><code>-D ./</code> 指定内存dump进程文件存储位置</li>
</ul>
</blockquote>
<p>运行指令得到：</p>
<p><img src="/images/OtterCTF_2018_Memory_Forensic_writeup/image-20221003014902581.png" alt="image-20221003014902581"></p>
<p>尝试检索dump出来的文件的字符串，使用如下命令：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>strings 708.dmp | grep Lunar-3
</span></span></code></pre></div><blockquote>
<p><strong>说明</strong></p>
<ul>
<li><code>strings 708.dmp</code> 打印出<code>708.dmp</code>二进制文件中的可打印字符</li>
<li><code>|</code>  管道符，可以将左边命令输出的数据传递右边的命令处理</li>
<li><code>grep Lunar-3</code> 检索有<code>Lunar</code>字符串所在的行并打印</li>
</ul>
</blockquote>
<p>运行命令得到：</p>
<p><img src="/images/OtterCTF_2018_Memory_Forensic_writeup/image-20221003015212113.png" alt="image-20221003015212113"></p>
<p>发现是存在相关字符串内容，增加点参数来获得字符串的上下文内容，执行如下命令：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>strings 708.dmp | grep Lunar-3 -A 3 -B 3
</span></span></code></pre></div><blockquote>
<p><strong>说明</strong></p>
<ul>
<li><code>-A 3</code> 检索字符串所在行的前3行</li>
<li><code>-B 3</code> 检索字符串所在行的后3行</li>
</ul>
</blockquote>
<p>执行命令得到：</p>
<p><img src="/images/OtterCTF_2018_Memory_Forensic_writeup/image-20221003020425640.png" alt="image-20221003020425640"></p>
<p>发现存在可疑字符串：<code>0tt3r8r33z3</code></p>
<p>感觉这个字符串应该就是用户名，尝试提交成功</p>
<p>故flag是：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>CTF{0tt3r8r33z3}
</span></span></code></pre></div><h2 id="name-game-2">
  Name Game 2
  <a class="heading-link" href="#name-game-2">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h2>
<p>查看题目描述：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>From a little research we found that the username of the logged on character is always after this signature: 0x64 0x??{6-8} 0x40 0x06 0x??{18} 0x5a 0x0c 0x00{2}
</span></span><span style="display:flex;"><span>What&#39;s rick&#39;s character&#39;s name?
</span></span></code></pre></div><p>这道题目应该寻找相关的字符，需要进行模糊搜索</p>
<p>这道题目有两种解题方法：</p>
<ol>
<li>使用Linux的<code>hexdump</code>和<code>grep</code>命令来进行联合检索</li>
<li>使用Hexedit类工具进行逐一寻找来确定相应位置</li>
</ol>
<h3 id="method-1">
  Method 1
  <a class="heading-link" href="#method-1">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h3>
<p>使用如下Linux命令：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>hexdump -C 708.dmp | grep <span style="font-style:italic">&#34;64&#34;</span> -A 5 -B 5 | grep <span style="font-style:italic">&#34;40 06&#34;</span> -A 5 -B 5 | grep <span style="font-style:italic">&#34;5a 0c 00 00&#34;</span> -A 5 -B 5
</span></span></code></pre></div><p>执行命令获得：</p>
<p><img src="/images/OtterCTF_2018_Memory_Forensic_writeup/image-20221003113309491.png" alt="image-20221003113309491"></p>
<p>由于dump文件比较大，因此，这个命令可能需要执行4-5min才能执行出来结果，运行命令比较简单，但是运行时间相对比较长。</p>
<p>运行得到的字符串就是<code>M0rtyL0L</code></p>
<p>故此题的flag就是<code>CTF{M0rtyL0L}</code></p>
<h3 id="method-2">
  Method 2
  <a class="heading-link" href="#method-2">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h3>
<p>使用WinHex之类的工具进行查看搜索<code>5a0c0000</code></p>
<p><img src="/images/OtterCTF_2018_Memory_Forensic_writeup/image-20221003115058149.png" alt="image-20221003115058149"></p>
<p>进行Hex value的搜索，依次对搜索列表进行比对和寻找：</p>
<p><img src="/images/OtterCTF_2018_Memory_Forensic_writeup/image-20221003115148926.png" alt="image-20221003115148926"></p>
<p>最后找到目标位置：</p>
<p><img src="/images/OtterCTF_2018_Memory_Forensic_writeup/image-20221003115217012.png" alt="image-20221003115217012"></p>
<p>这种方式要进行查找比对，查找速度快的话是比Linux命令要快些，但是就是需要不断的人工比对和查看</p>
<p>得到字符串<code>M0rtyL0L</code></p>
<p>故此题的flag就是<code>CTF{M0rtyL0L}</code></p>
<p>这两种解题方法各有利弊，可以根据个人的喜好选择求解，个人更倾向于Linux那种解法，输入完命令就可以喝杯茶慢慢等，一会儿结果就出来了</p>
<h2 id="silly-rick">
  Silly Rick
  <a class="heading-link" href="#silly-rick">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h2>
<p>查看题目描述</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>Silly rick always forgets his email&#39;s password, so he uses a Stored Password Services online to store his password. He always copy and paste the password so he will not get it wrong. whats rick&#39;s email password?
</span></span></code></pre></div><p>根据题目描述，可以确定的关键语句<code>copy and paste</code>，说明邮箱地址应该是存储在粘贴板上面，可以查看下内存的粘贴板。</p>
<p>使用vol的如下指令查看粘贴板信息：</p>
<p><img src="/images/OtterCTF_2018_Memory_Forensic_writeup/image-20221003131135095.png" alt="image-20221003131135095"></p>
<p>可以发现的粘贴板信息：<code>M@il_Pr0vid0rs</code></p>
<p>故此题的flag就是：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>CTF{M@il_Pr0vid0rs}
</span></span></code></pre></div><h2 id="hide-and-seek">
  Hide And Seek
  <a class="heading-link" href="#hide-and-seek">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h2>
<p>查看题目描述</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>The reason that we took rick&#39;s PC memory dump is because there was a malware infection. Please find the malware process name (including the extension)
</span></span></code></pre></div><p>根据题目描述，应该是需要寻找下恶意软件进程名称，vol这个软件功能非常强大，可以直接使用<code>malfind</code>的参数进行扫描，使用如下指令：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>vol.py -f OtterCTF.vmem --profile=Win7SP1x64 malfind | grep Process
</span></span></code></pre></div><p>得到恶意进程信息：</p>
<p><img src="/images/OtterCTF_2018_Memory_Forensic_writeup/image-20221003180849409.png" alt="image-20221003180849409"></p>
<p>可以简单的归纳下恶意进程的信息：</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Pid</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>WmiPrvSE.exe</code></td>
<td>2136</td>
</tr>
<tr>
<td><code>explorer.exe</code></td>
<td>2728</td>
</tr>
<tr>
<td><code>BitTorrent.exe</code></td>
<td>2836</td>
</tr>
<tr>
<td><code>PresentationFo</code></td>
<td>724</td>
</tr>
<tr>
<td><code>mscorsvw.exe</code></td>
<td>412</td>
</tr>
<tr>
<td><code>mscorsvw.exe</code></td>
<td>3124</td>
</tr>
<tr>
<td><code>svchost.exe</code></td>
<td>3196</td>
</tr>
<tr>
<td><code>chrome.exe</code></td>
<td>4076</td>
</tr>
<tr>
<td><code>vmware-tray.ex</code></td>
<td>3720</td>
</tr>
<tr>
<td><code>WebCompanionIn</code></td>
<td>3880</td>
</tr>
<tr>
<td><code>Lavasoft.WCAss</code></td>
<td>3496</td>
</tr>
<tr>
<td><code>WebCompanion.e</code></td>
<td>3856</td>
</tr>
</tbody>
</table>
<p>这些是可能的恶意进程，需要找到题目要求的恶意进程，看看进程的cmd指令，使用如下指令：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>vol.py -f OtterCTF.vmem --profile=Win7SP1x64 cmdline
</span></span></code></pre></div><p>得到：</p>
<p><img src="/images/OtterCTF_2018_Memory_Forensic_writeup/image-20221004150006413.png" alt="image-20221004150006413"></p>
<p>可以看到有一个进程是在Temp目录下进行执行，这个进程应该就是恶意进程了，一般恶意进程会在Temp目录中运行。</p>
<p>故恶意进程就是<code>vmware-tray.exe</code></p>
<p>故此题的flag就是<code>CTF{vmware-tray.exe}</code></p>
<h2 id="path-to-glory">
  Path To Glory
  <a class="heading-link" href="#path-to-glory">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h2>
<p>查看题目描述：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>How did the malware got to rick&#39;s PC? It must be one of rick old illegal habits...
</span></span></code></pre></div><p>应该是要寻找的Rick的不良习惯，进行文件扫描来尝试确定可疑的文件</p>
<p>文件扫描使用<code>filescan</code>指令，由于是要寻找Rick的文件需要进行简单过滤下，使用如下命令：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>vol.py -f OtterCTF.vmem --profile=Win7SP1x64 filescan | grep -i <span style="font-style:italic">&#34;Rick&#34;</span>
</span></span></code></pre></div><blockquote>
<p><strong>说明</strong></p>
<ul>
<li><code>grep -i &quot;Rick&quot;</code> 忽略大小写检索<code>Rick</code></li>
</ul>
</blockquote>
<p>得到：</p>
<p><img src="/images/OtterCTF_2018_Memory_Forensic_writeup/image-20221004163351355.png" alt="image-20221004163351355"></p>
<p>发现一个torrent文件，可以猜测Rick应该平时会进行torrent种子文件的下载，而且这个种子文件的位置一般是在<code>Rick And Morty</code>文件夹下面。因此，进一步过滤查看相关信息，使用如下指令：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>vol.py -f OtterCTF.vmem --profile=Win7SP1x64 filescan | grep -i <span style="font-style:italic">&#34;Rick And Morty&#34;</span>
</span></span></code></pre></div><p>得到：</p>
<p><img src="/images/OtterCTF_2018_Memory_Forensic_writeup/image-20221004164710378.png" alt="image-20221004164710378"></p>
<p>发现有一个文件的权限比较可疑，尝试将这个文件进行dump，来查看文件具体信息</p>
<p>使用如下命令进行dump：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>vol.py -f OtterCTF.vmem --profile=Win7SP1x64 dumpfiles -Q 0x000000007dae9350 -D ./
</span></span></code></pre></div><blockquote>
<p><strong>说明</strong></p>
<ul>
<li><code>dumpfiles</code> dump文件指令</li>
<li><code>-Q 0x000000007dae9350 </code> 以物理偏移为<code>0x000000007dae9350</code>的文件作为对象</li>
<li><code>-D ./</code> dump文件目录在<code>./</code>目录下</li>
</ul>
</blockquote>
<p>得到：</p>
<p><img src="/images/OtterCTF_2018_Memory_Forensic_writeup/image-20221004170421613.png" alt="image-20221004170421613"></p>
<p>查看下dump文件中的可打印字符串数据</p>
<p>执行如下命令：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>strings file.None.0xfffffa801b42c9e0.dat
</span></span></code></pre></div><p>得到可打印字符串信息：</p>
<p><img src="/images/OtterCTF_2018_Memory_Forensic_writeup/image-20221004170725684.png" alt="image-20221004170725684"></p>
<p>故此题的flag应该是藏在<code>e7:website19:M3an_T0rren7_4_R!cke</code>这段字符串中，对这段字符串仔细观察，可以发现这段字符串是有一些明显特征的</p>
<p>可以发现<code>e</code>是作为开头结尾的引用，中间的数据就是<code>7:website19:M3an_T0rren7_4_R!ck</code>，应该是三个对象显然最后一个对象应该是就是flag</p>
<p>故此题的flag就是<code>CTF{M3an_T0rren7_4_R!ck}</code></p>
<h2 id="path-to-glory-2">
  Path To Glory 2
  <a class="heading-link" href="#path-to-glory-2">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h2>
<p>查看题目描述：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>Continue the search after the way that malware got in.
</span></span></code></pre></div><p>需要继续寻找关于恶意软件的信息，要往深入探索应该需要探索浏览器的相关信息，由于Rick被恶意攻击是由于Rick在浏览器上下载种子文件</p>
<p>把浏览器的进程内存dump出来查看关键的信息</p>
<p>使用如下指令来dump相关信息：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>vol.py -f OtterCTF.vmem --profile=Win7SP1x64 memdump -n chrome -D ./f/
</span></span></code></pre></div><blockquote>
<p><strong>说明</strong></p>
<ul>
<li><code>memdump</code> dump内存命令</li>
<li><code>-n chrome</code> 以进程名称作为内存对象</li>
<li><code>-D ./f/</code> dump内存文件<code>./f/</code>目录</li>
</ul>
</blockquote>
<p><img src="/images/OtterCTF_2018_Memory_Forensic_writeup/image-20221004201432915.png" alt="image-20221004201432915"></p>
<p>使用<code>strings</code>命令来获取内存文件的可打印字符串，并添加<code>download.exe.torrent</code>作为过滤，由于恶意文件名是<code>download.exe.torrent</code>，因此采用这种方式进行过滤</p>
<p>使用如下指令：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>strings ./f/* | grep <span style="font-style:italic">&#34;download\.exe\.torrent&#34;</span> -A 10 -B 10
</span></span></code></pre></div><p>得到：</p>
<p><img src="/images/OtterCTF_2018_Memory_Forensic_writeup/image-20221004204205771.png" alt="image-20221004204205771"></p>
<p>这串字符看样子是挺奇怪的，应该就是flag信息</p>
<p>尝试发现真正的flag数据是<code>Hum@n_I5_Th3_Weak3s7_Link_In_Th3_Ch@in</code></p>
<p>故此题的flag是<code>CTF{Hum@n_I5_Th3_Weak3s7_Link_In_Th3_Ch@in}</code></p>
<h2 id="bit-4-bit">
  Bit 4 Bit
  <a class="heading-link" href="#bit-4-bit">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h2>
<p>查看题目描述：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>We&#39;ve found out that the malware is a ransomware. Find the attacker&#39;s bitcoin address.
</span></span></code></pre></div><p>恶意软件是一个勒索软件，需要将那个恶意软件进行分析</p>
<p>首先需要dump出恶意软件的进程，使用<code>procdump</code>将进程dump作为一个可执行程序</p>
<p>使用如下命令进行dump：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>vol.py -f OtterCTF.vmem --profile=Win7SP1x64 procdump -p 3720 -D ./
</span></span></code></pre></div><blockquote>
<p><strong>说明</strong></p>
<ul>
<li><code>procdump</code> dump进程作为一个可执行文件</li>
<li><code>-p 3720</code>  以PID作为进程对象</li>
<li><code>-D ./</code>  将可执行文件存储在<code>./</code>目录</li>
</ul>
</blockquote>
<p>得到：</p>
<p><img src="/images/OtterCTF_2018_Memory_Forensic_writeup/image-20221004210324575.png" alt="image-20221004210324575"></p>
<p>需要对文件进行分析，首先查看软件的相关信息：</p>
<p><img src="/images/OtterCTF_2018_Memory_Forensic_writeup/image-20221004210448989.png" alt="image-20221004210448989"></p>
<p>发现恶意软件是一个.NET的文件，可以使用dnSpy进行查看，拖进dnSpy进行寻找发现：</p>
<p><img src="/images/OtterCTF_2018_Memory_Forensic_writeup/image-20221004210559036.png" alt="image-20221004210559036"></p>
<p>一个GUI绘制流，根据GUI的代码信息，使用PS绘制出GUI：</p>
<p><img src="/images/OtterCTF_2018_Memory_Forensic_writeup/image-20221004211105657.png" alt="image-20221004211105657"></p>
<p>比特币地址显而易见就是：<code>1MmpEmebJkqXG8nQv4cjJSmxZQFVmFo63M</code></p>
<p>故此题的flag就是<code>CTF{1MmpEmebJkqXG8nQv4cjJSmxZQFVmFo63M}</code></p>
<h2 id="graphics-for-the-weak">
  Graphic’s For The Weak
  <a class="heading-link" href="#graphics-for-the-weak">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h2>
<p>查看题目描述：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>There&#39;s something fishy in the malware&#39;s graphics.
</span></span></code></pre></div><p>使用dnSpy加载恶意软件，可以在资源目录中找到：</p>
<p><img src="/images/OtterCTF_2018_Memory_Forensic_writeup/image-20221004212217979.png" alt="image-20221004212217979"></p>
<p>故本题的flag就是<code>CTF{S0_Just_M0v3_Socy}</code></p>
<h2 id="recovery">
  Recovery
  <a class="heading-link" href="#recovery">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h2>
<p>查看题目描述：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>Rick got to have his files recovered! What is the random password used to encrypt the files?
</span></span></code></pre></div><p>对恶意软件进行审计，找到关键的密码发送函数：</p>
<p><img src="/images/OtterCTF_2018_Memory_Forensic_writeup/image-20221004214117780.png" alt="image-20221004214117780"></p>
<p>发现密码是根据计算机名称和用户名以及密码一起发送的，要dump恶意软件的内存信息，使用如下指令进行dump：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>vol.py -f OtterCTF.vmem --profile=Win7SP1x64 memdump -p 3720 -D ./
</span></span></code></pre></div><p>执行命令得到：</p>
<p><img src="/images/OtterCTF_2018_Memory_Forensic_writeup/image-20221004214626524.png" alt="image-20221004214626524"></p>
<p>使用<code>strings</code>命令进行检索，由于程序的数据是16字节小端序数据，.NET程序的用2字节表示一个字符串，所以是16字节小端序数据，因此使用如下命令进行过滤检索：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>strings -el 3720.dmp | grep WIN-LO6FAF3DTFE-Rick
</span></span></code></pre></div><p>运行得到：</p>
<p><img src="/images/OtterCTF_2018_Memory_Forensic_writeup/image-20221004215044513.png" alt="image-20221004215044513"></p>
<p>故此，密码就是<code>aDOBofVYUNVnmp7</code></p>
<p>故此题的flag就是<code>CTF{aDOBofVYUNVnmp7}</code></p>
<h2 id="closure">
  Closure
  <a class="heading-link" href="#closure">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h2>
<p>查看题目描述：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>Now that you extracted the password from the memory, could you decrypt rick&#39;s files?
</span></span></code></pre></div><p>要找文件并且解密文件。猜测存在一个flag文件，使用如下指令进行文件扫描：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>vol.py -f OtterCTF.vmem --profile=Win7SP1x64 filescan | grep -i &#34;flag&#34;
</span></span></code></pre></div><p>运行命令得到：</p>
<p><img src="/images/OtterCTF_2018_Memory_Forensic_writeup/image-20221004215615853.png" alt="image-20221004215615853"></p>
<p>应该是桌面上的<code>Flag.txt</code>文件</p>
<p>将文件进行dump，使用如下命令进行文件dump：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>ol.py -f OtterCTF.vmem --profile=Win7SP1x64 dumpfiles -Q 0x000000007e410890 -D ./
</span></span></code></pre></div><p>运行得到：</p>
<p><img src="/images/OtterCTF_2018_Memory_Forensic_writeup/image-20221004220208957.png" alt="image-20221004220208957"></p>
<p>下面就需要对文件进行解密了</p>
<p>首先对dnSpy反编译的代码进行审计可以看到是：</p>
<p><img src="/images/OtterCTF_2018_Memory_Forensic_writeup/image-20221004225734265.png" alt="image-20221004225734265"></p>
<p>hidden tear的程序算法</p>
<p>继续进行分析，可以发现一个AES的加密算法：</p>
<p><img src="/images/OtterCTF_2018_Memory_Forensic_writeup/image-20221004230040181.png" alt="image-20221004230040181"></p>
<p>进行跟进分析可以发现一个加密文件的函数：</p>
<p><img src="/images/OtterCTF_2018_Memory_Forensic_writeup/image-20221004230149524.png" alt="image-20221004230149524"></p>
<p>对这两个关键函数进行代码审计发现，核心的加密算法还是AES的算法</p>
<p>根据目前的分析情况，如果要解密这个文件主要有两种思路</p>
<ul>
<li>根据加密算法写解密脚本进行解密</li>
<li>使用HiddenTearDecrypt工具进行解密</li>
</ul>
<h3 id="hiddenteardecrypt工具解密">
  HiddenTearDecrypt工具解密
  <a class="heading-link" href="#hiddenteardecrypt%e5%b7%a5%e5%85%b7%e8%a7%a3%e5%af%86">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h3>
<p>由于在文件中发现了HiddenTear的关键信息，可以直接去检索HiddenTearDecrypt:</p>
<p><img src="/images/OtterCTF_2018_Memory_Forensic_writeup/image-20221004230418792.png" alt="image-20221004230418792"></p>
<p>HiddenTearDecrypt工具在网络上都是可以进行下载的</p>
<p>尝试使用工具进行解密发现不能成功求解。由于加密代码是采用CBC模式进行加密，会对文件进行填充，只要删除掉文件的填充应该就可以正常解密，使用winhex打开文件：</p>
<p><img src="/images/OtterCTF_2018_Memory_Forensic_writeup/image-20221004230652451.png" alt="image-20221004230652451"></p>
<p>可以发现有很多<code>00</code>字节的填充，只要删除<code>00</code>字节的填充就可以进行正常的解密，使用工具进行解密</p>
<p><img src="/images/OtterCTF_2018_Memory_Forensic_writeup/image-20221004230849821.png" alt="image-20221004230849821"></p>
<p>解密成功，打开文件得到flag：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>CTF{Im_Th@_B3S7_RicK_0f_Th3m_4ll}
</span></span></code></pre></div><h3 id="解密脚本解密">
  解密脚本解密
  <a class="heading-link" href="#%e8%a7%a3%e5%af%86%e8%84%9a%e6%9c%ac%e8%a7%a3%e5%af%86">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h3>
<p>由于加密代码已经进行分析，对于加密的情况已经基本清晰</p>
<p>Python编写解密脚本的难点应该是在于生成器的替代，CS中的<code>Rfc2898DeriveBytes</code>可以使用Python中的<code>PBKDF2</code>进行替代</p>
<p>解密脚本主要难度其实已经克服，根据加密写解密脚本：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="font-weight:bold">from</span> <span style="font-weight:bold">Crypto.Protocol.KDF</span> <span style="font-weight:bold">import</span> PBKDF2
</span></span><span style="display:flex;"><span><span style="font-weight:bold">from</span> <span style="font-weight:bold">Crypto.Cipher</span> <span style="font-weight:bold">import</span> AES
</span></span><span style="display:flex;"><span><span style="font-weight:bold">from</span> <span style="font-weight:bold">hashlib</span> <span style="font-weight:bold">import</span> sha256
</span></span><span style="display:flex;"><span><span style="font-weight:bold">def</span> AES_Decrypt(c,password):
</span></span><span style="display:flex;"><span>    salt = bytes([1, 2, 3, 4, 5, 6, 7, 8])
</span></span><span style="display:flex;"><span>    kdf = PBKDF2(password, salt, 48, count = 1000)
</span></span><span style="display:flex;"><span>    key = kdf[:32]
</span></span><span style="display:flex;"><span>    iv = kdf[32:]
</span></span><span style="display:flex;"><span>    aes = AES.new(key=key,iv=iv,mode=AES.MODE_CBC)
</span></span><span style="display:flex;"><span>    m = aes.decrypt(c)
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> m
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>password = <span style="font-style:italic">b</span><span style="font-style:italic">&#34;aDOBofVYUNVnmp7&#34;</span>
</span></span><span style="display:flex;"><span>p = sha256(password).digest()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">with</span> open(<span style="font-style:italic">&#34;./file.dat&#34;</span>,<span style="font-style:italic">&#34;rb&#34;</span>) <span style="font-weight:bold">as</span> f:
</span></span><span style="display:flex;"><span>    data = f.read()
</span></span><span style="display:flex;"><span>    raw = AES_Decrypt(data,p)
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">with</span> open(<span style="font-style:italic">&#34;./file.txt&#34;</span>,<span style="font-style:italic">&#34;wb&#34;</span>) <span style="font-weight:bold">as</span> new:
</span></span><span style="display:flex;"><span>        new.write(raw)
</span></span></code></pre></div><p>运行后得到解密文件，打开文件得到flag：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>CTF{Im_Th@_B3S7_RicK_0f_Th3m_4ll}
</span></span></code></pre></div><p>两种解法都可以正常进行求解，求解得到flag。</p>
<p>用工具求解可能比较快，但是存在一定的局限性，需要对加密文件进行一定的处理</p>
<p>用脚本求解可能相对较慢，但是比较灵活可以灵活地处理文件，对解密脚本编写熟练的，可以尝试写脚本求解，速度也不慢</p>

      </div>


      <footer>
        


        <div id="disqus_thread"></div>
<script type="application/javascript">
    window.disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "yourdiscussshortname" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
        
        
      </footer>
    </article>

    
  </section>

    </div>

    <footer class="footer">
  <section class="container">
    ©
    
      2019 -
    
    2022
     OrcasCode 
    ·
    
    Powered by <a href="https://gohugo.io/">Hugo</a> & <a href="https://github.com/luizdepra/hugo-coder/">Coder</a>.
    
  </section>
</footer>

  </main>

  
  
  <script src="/js/coder.min.236049395dc3682fb2719640872958e12f1f24067bb09c327b233e6290c7edac.js" integrity="sha256-I2BJOV3DaC&#43;ycZZAhylY4S8fJAZ7sJwyeyM&#43;YpDH7aw="></script>
  

  

  

  

  

  

  

  

  

  
</body>

</html>
