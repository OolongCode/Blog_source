<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="color-scheme" content="light dark">




<meta name="author" content="OrcasCode">
<meta name="description" content="攻防世界 RE 进阶区 日常练习 001ISCC比赛临近，CTF比赛题目也要开始继续训练起来 前段时间，由于准备升学相关的事宜，没有进行比赛的训练 手感相对而言，有些生疏 简单从攻防世界平台找几道逆向的题目进行简单的练习下
这几道题目主要都是使用IDA pro的远程调试功能，使用虚拟机搭配IDA进行远程调试
re2-cpp-is-awesome先查看一些文件的简单信息 ELF文件，GCC编译，无壳
IDA看下： C&#43;&#43;编译的程序文件，看的心烦意乱基本上找不到关键的函数，和关键的位置。
尝试使用下IDA pro的动调寻找一下f关键位置(IDA pro的动态消失配置可以自己网络检索，有很多相关的内容)
先断在第一个跳转位置，即jz short loc_400BD7 位置上
进行几次调试，发现都直接退出，没有进行跳转 也就是 cmp [rbp&#43;var_64], 2 的比较值没有改变ZF标志位 对上面汇编代码进行审计：
main proc near var_70= qword ptr -70h var_64= dword ptr -64h var_60= qword ptr -60h var_50= byte ptr -50h var_21= byte ptr -21h var_20= qword ptr -20h var_14= dword ptr -14h push rbp mov rbp, rsp push rbx sub rsp, 68h mov [rbp&#43;var_64], edi mov [rbp&#43;var_70], rsi cmp [rbp&#43;var_64], 2 指令cmp [rbp&#43;var_64], 2是一个条件判断，根据这个语句寻找下变量">
<meta name="keywords" content="blog,developer,personal">

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="攻防世界进阶区日常训练001"/>
<meta name="twitter:description" content="攻防世界 RE 进阶区 日常练习 001ISCC比赛临近，CTF比赛题目也要开始继续训练起来 前段时间，由于准备升学相关的事宜，没有进行比赛的训练 手感相对而言，有些生疏 简单从攻防世界平台找几道逆向的题目进行简单的练习下
这几道题目主要都是使用IDA pro的远程调试功能，使用虚拟机搭配IDA进行远程调试
re2-cpp-is-awesome先查看一些文件的简单信息 ELF文件，GCC编译，无壳
IDA看下： C&#43;&#43;编译的程序文件，看的心烦意乱基本上找不到关键的函数，和关键的位置。
尝试使用下IDA pro的动调寻找一下f关键位置(IDA pro的动态消失配置可以自己网络检索，有很多相关的内容)
先断在第一个跳转位置，即jz short loc_400BD7 位置上
进行几次调试，发现都直接退出，没有进行跳转 也就是 cmp [rbp&#43;var_64], 2 的比较值没有改变ZF标志位 对上面汇编代码进行审计：
main proc near var_70= qword ptr -70h var_64= dword ptr -64h var_60= qword ptr -60h var_50= byte ptr -50h var_21= byte ptr -21h var_20= qword ptr -20h var_14= dword ptr -14h push rbp mov rbp, rsp push rbx sub rsp, 68h mov [rbp&#43;var_64], edi mov [rbp&#43;var_70], rsi cmp [rbp&#43;var_64], 2 指令cmp [rbp&#43;var_64], 2是一个条件判断，根据这个语句寻找下变量"/>

<meta property="og:title" content="攻防世界进阶区日常训练001" />
<meta property="og:description" content="攻防世界 RE 进阶区 日常练习 001ISCC比赛临近，CTF比赛题目也要开始继续训练起来 前段时间，由于准备升学相关的事宜，没有进行比赛的训练 手感相对而言，有些生疏 简单从攻防世界平台找几道逆向的题目进行简单的练习下
这几道题目主要都是使用IDA pro的远程调试功能，使用虚拟机搭配IDA进行远程调试
re2-cpp-is-awesome先查看一些文件的简单信息 ELF文件，GCC编译，无壳
IDA看下： C&#43;&#43;编译的程序文件，看的心烦意乱基本上找不到关键的函数，和关键的位置。
尝试使用下IDA pro的动调寻找一下f关键位置(IDA pro的动态消失配置可以自己网络检索，有很多相关的内容)
先断在第一个跳转位置，即jz short loc_400BD7 位置上
进行几次调试，发现都直接退出，没有进行跳转 也就是 cmp [rbp&#43;var_64], 2 的比较值没有改变ZF标志位 对上面汇编代码进行审计：
main proc near var_70= qword ptr -70h var_64= dword ptr -64h var_60= qword ptr -60h var_50= byte ptr -50h var_21= byte ptr -21h var_20= qword ptr -20h var_14= dword ptr -14h push rbp mov rbp, rsp push rbx sub rsp, 68h mov [rbp&#43;var_64], edi mov [rbp&#43;var_70], rsi cmp [rbp&#43;var_64], 2 指令cmp [rbp&#43;var_64], 2是一个条件判断，根据这个语句寻找下变量" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.codetea.top/posts/xctf-reverse-advanced_daliy_001/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-04-23T15:14:39+08:00" />
<meta property="article:modified_time" content="2022-04-23T15:14:39+08:00" />




  <title>OPdbg</title>

  
  <link rel="canonical" href="https://www.codetea.top/posts/xctf-reverse-advanced_daliy_001/">
  

  <link rel="preload" href="/fonts/forkawesome-webfont.woff2?v=1.2.0" as="font" type="font/woff2" crossorigin>


  
  
  <link rel="stylesheet" href="/css/coder.min.6b1a4fbc48955b72aea7913e43fabeb45e8bc120da5aa41b598dd33adcac4b59.css" integrity="sha256-axpPvEiVW3Kup5E&#43;Q/q&#43;tF6LwSDaWqQbWY3TOtysS1k=" crossorigin="anonymous" media="screen" />





  
  
    
    
    <link rel="stylesheet" href="/css/coder-dark.min.39e41a7f16bdf8cb16e43cae7d714fa1016f1d2d2898a5b3f27f42c9979204e2.css" integrity="sha256-OeQafxa9&#43;MsW5DyufXFPoQFvHS0omKWz8n9CyZeSBOI=" crossorigin="anonymous" media="screen" />
  



   





  <link rel="icon" type="image/png" href="/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="/favicon-16x16.png" sizes="16x16">

<link rel="apple-touch-icon" href="/images/apple-touch-icon.png">
<link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

<link rel="manifest" href="/site.webmanifest">
<link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#5bbad5">


  

  <meta name="generator" content="Hugo 0.101.0" />


  
<script>
  MathJax = {
    tex: {
      inlineMath: [["$", "$"]],
    },
    displayMath: [
      ["$$", "$$"],
      ["\[\[", "\]\]"],
    ],
    svg: {
      fontCache: "global",
    },
  };
</script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"
></script>


  <script>renderMathInElement(document.body);</script>

<link href="https://cdn.bootcdn.net/ajax/libs/highlight.js/11.5.1/styles/atom-one-dark-reasonable.min.css" rel="stylesheet">
<script src="https://cdn.bootcdn.net/ajax/libs/highlight.js/11.5.1/highlight.min.js"></script>
<script src="https://cdn.bootcdn.net/ajax/libs/highlight.js/11.5.1/languages/armasm.min.js"></script>
<script src="https://cdn.bootcdn.net/ajax/libs/highlight.js/11.5.1/languages/mipsasm.min.js"></script>
<script src="https://cdn.bootcdn.net/ajax/libs/highlight.js/11.5.1/languages/wasm.min.js"></script>
<script src="https://cdn.bootcdn.net/ajax/libs/highlight.js/11.5.1/languages/x86asm.min.js"></script>
<script>hljs.highlightAll();</script>
</head>







<body class="preload-transitions colorscheme-auto">
  
<div class="float-container">
    <a id="dark-mode-toggle" class="colorscheme-toggle">
        <i class="fa fa-adjust fa-fw" aria-hidden="true"></i>
    </a>
</div>


  <main class="wrapper">
    <nav class="navigation">
  <section class="container">
    <a class="navigation-title" href="/">
      OPdbg
    </a>
    
      <input type="checkbox" id="menu-toggle" />
      <label class="menu-button float-right" for="menu-toggle">
        <i class="fa fa-bars fa-fw" aria-hidden="true"></i>
      </label>
      <ul class="navigation-list">
        
          
            <li class="navigation-item">
              <a class="navigation-link" href="/about/">About</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="/posts/">Posts</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="/categories/">Categories</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="/tags/">Tags</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="/link/">Link</a>
            </li>
          
        
        
      </ul>
    
  </section>
</nav>


    <div class="content">
      
  <section class="container post">
    <article>
      <header>
        <div class="post-title">
          <h1 class="title">
            <a class="title-link" href="https://www.codetea.top/posts/xctf-reverse-advanced_daliy_001/">
              攻防世界进阶区日常训练001
            </a>
          </h1>
        </div>
        <div class="post-meta">
          <div class="date">
            <span class="posted-on">
              <i class="fa fa-calendar" aria-hidden="true"></i>
              <time datetime="2022-04-23T15:14:39&#43;08:00">
                April 23, 2022
              </time>
            </span>
            <span class="reading-time">
              <i class="fa fa-clock-o" aria-hidden="true"></i>
              14-minute read
            </span>
          </div>
          
          <div class="categories">
  <i class="fa fa-folder" aria-hidden="true"></i>
    <a href="/categories/practice/">practice</a></div>

          <div class="tags">
  <i class="fa fa-tag" aria-hidden="true"></i>
    <span class="tag">
      <a href="/tags/ctf/">ctf</a>
    </span>
      <span class="separator">•</span>
    <span class="tag">
      <a href="/tags/writeup/">writeup</a>
    </span>
      <span class="separator">•</span>
    <span class="tag">
      <a href="/tags/reverse/">reverse</a>
    </span></div>

        </div>
      </header>

      <div>
        
        <h1 id="攻防世界-re-进阶区-日常练习-001">
  攻防世界 RE 进阶区 日常练习 001
  <a class="heading-link" href="#%e6%94%bb%e9%98%b2%e4%b8%96%e7%95%8c-re-%e8%bf%9b%e9%98%b6%e5%8c%ba-%e6%97%a5%e5%b8%b8%e7%bb%83%e4%b9%a0-001">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h1>
<blockquote>
<p>ISCC比赛临近，CTF比赛题目也要开始继续训练起来
前段时间，由于准备升学相关的事宜，没有进行比赛的训练
手感相对而言，有些生疏
简单从攻防世界平台找几道逆向的题目进行简单的练习下</p>
</blockquote>
<p>这几道题目主要都是使用IDA pro的远程调试功能，使用虚拟机搭配IDA进行远程调试</p>
<h2 id="re2-cpp-is-awesome">
  re2-cpp-is-awesome
  <a class="heading-link" href="#re2-cpp-is-awesome">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h2>
<p>先查看一些文件的简单信息
<img src="/images/XCTF-REVERSE-DAILY/Pasted_image_20220420210740.png" alt=""></p>
<p>ELF文件，GCC编译，无壳</p>
<p>IDA看下：
C++编译的程序文件，看的心烦意乱基本上找不到关键的函数，和关键的位置。</p>
<p>尝试使用下IDA pro的动调寻找一下f关键位置(IDA pro的动态消失配置可以自己网络检索，有很多相关的内容)</p>
<p>先断在第一个跳转位置，即<code>jz short loc_400BD7</code> 位置上</p>
<p><img src="/images/XCTF-REVERSE-DAILY/Pasted_image_20220420213518.png" alt=""></p>
<p>进行几次调试，发现都直接退出，没有进行跳转
也就是 <code>cmp [rbp+var_64], 2</code> 的比较值没有改变ZF标志位
对上面汇编代码进行审计：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>main proc near                       
</span></span><span style="display:flex;"><span>var_70= qword ptr -70h
</span></span><span style="display:flex;"><span>var_64= dword ptr -64h
</span></span><span style="display:flex;"><span>var_60= qword ptr -60h
</span></span><span style="display:flex;"><span>var_50= byte ptr -50h
</span></span><span style="display:flex;"><span>var_21= byte ptr -21h
</span></span><span style="display:flex;"><span>var_20= qword ptr -20h
</span></span><span style="display:flex;"><span>var_14= dword ptr -14h
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>push    rbp
</span></span><span style="display:flex;"><span>mov     rbp, rsp
</span></span><span style="display:flex;"><span>push    rbx
</span></span><span style="display:flex;"><span>sub     rsp, 68h
</span></span><span style="display:flex;"><span>mov     [rbp+var_64], edi
</span></span><span style="display:flex;"><span>mov     [rbp+var_70], rsi
</span></span><span style="display:flex;"><span>cmp     [rbp+var_64], 2
</span></span></code></pre></div><p>指令<code>cmp [rbp+var_64], 2</code>是一个条件判断，根据这个语句寻找下变量</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>rbp+64 = edi
</span></span></code></pre></div><p>根据Linux x64 fastcall的调用约定，可以知道<code>edi</code>寄存器存储着函数的第一个参数，<code>main</code>函数的第一参数是运行程序附加的参数。所以根据条件，应该是程序运行的时候要携带一个参数进行运行。</p>
<p>因此，尝试使用传参调用来进行寻找关键的函数（当然也可以使用修改ZF标志位）。现在进入下一步的探索：</p>
<p><img src="/images/XCTF-REVERSE-DAILY/Pasted_image_20220421000556.png" alt=""></p>
<p>一路F8寻找退出位置，找到退出位置是在<code>call sub_400B56</code>位置
点开函数看下</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>sub_400B56      proc near       ; CODE XREF: main+F5↓p
</span></span><span style="display:flex;"><span>push    rbp
</span></span><span style="display:flex;"><span>mov     rbp, rsp
</span></span><span style="display:flex;"><span>mov     esi, offset aBetterLuckNext ; &#34;Better luck next time\n&#34;
</span></span><span style="display:flex;"><span>mov     edi, offset _ZSt4cout ; std::cout
</span></span><span style="display:flex;"><span>call    __ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc ; std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(std::ostream &amp;,char const*)
</span></span><span style="display:flex;"><span>mov     edi, 0          ; status
</span></span><span style="display:flex;"><span>call    _exit
</span></span></code></pre></div><p>简单审计下，发现函数，就是一个错误输出的函数，应该不是关键判断的位置。因此，需要往上继续寻找。</p>
<p>退出函数上面有<code>jz short loc_400C83</code>跳转，说明应该是存在条件判断，进行向上寻找条件判断的语句。</p>
<p>找到<code>cmp dl al</code>指令这个应该是核心的条件判断指令
指令比较的是dl寄存器和al寄存器存储的值
dl寄存器是dx寄存器的低位，al寄存器是ax寄存器的低位。相应地，寻找下对eax或rax、edx或rdx的操作</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>lea     rax, [rbp+var_50]
</span></span><span style="display:flex;"><span>mov     rdi, rax
</span></span><span style="display:flex;"><span>call    __ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE3endEv ; std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::end(void)
</span></span><span style="display:flex;"><span>mov     [rbp+var_20], rax
</span></span><span style="display:flex;"><span>lea     rdx, [rbp+var_20]
</span></span><span style="display:flex;"><span>lea     rax, [rbp+var_60]
</span></span><span style="display:flex;"><span>mov     rsi, rdx
</span></span><span style="display:flex;"><span>mov     rdi, rax
</span></span><span style="display:flex;"><span>call    sub_400D3D
</span></span><span style="display:flex;"><span>test    al, al
</span></span><span style="display:flex;"><span>jz      short loc_400C95
</span></span><span style="display:flex;"><span>lea     rax, [rbp+var_60]
</span></span><span style="display:flex;"><span>mov     rdi, rax
</span></span><span style="display:flex;"><span>call    sub_400D9A
</span></span><span style="display:flex;"><span>movzx   edx, byte ptr [rax]
</span></span><span style="display:flex;"><span>mov     rcx, cs:off_6020A0 ; &#34;L3t_ME_T3ll_Y0u_S0m3th1ng_1mp0rtant_A_{&#34;...
</span></span><span style="display:flex;"><span>mov     eax, [rbp+var_14]
</span></span><span style="display:flex;"><span>cdqe
</span></span><span style="display:flex;"><span>mov     eax, dword_6020C0[rax*4]
</span></span><span style="display:flex;"><span>cdqe
</span></span><span style="display:flex;"><span>add     rax, rcx
</span></span><span style="display:flex;"><span>movzx   eax, byte ptr [rax]
</span></span></code></pre></div><p>可以寻找到相应的关系，由于C++面向对象STL反汇编实在是比较难搞懂，经过反复调试，发现关键的函数是在这几行：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>movzx   edx, byte ptr [rax]
</span></span><span style="display:flex;"><span>mov     rcx, cs:off_6020A0 ; &#34;L3t_ME_T3ll_Y0u_S0m3th1ng_1mp0rtant_A_{&#34;...
</span></span><span style="display:flex;"><span>mov     eax, [rbp+var_14]
</span></span><span style="display:flex;"><span>cdqe
</span></span><span style="display:flex;"><span>mov     eax, dword_6020C0[rax*4]
</span></span><span style="display:flex;"><span>cdqe
</span></span><span style="display:flex;"><span>add     rax, rcx
</span></span><span style="display:flex;"><span>movzx   eax, byte ptr [rax]
</span></span></code></pre></div><p>对于这个指令，应该就是对数组进行取值组合，可以看下<code>dword_6020C0</code>存储的数据
<img src="/images/XCTF-REVERSE-DAILY/Pasted_image_20220421235604.png" alt="">
中间的<code>align 8</code> 指令会根据不同编译器和cpu而呈现不同的行为，<code>align</code>指令简单来说也就是数据宽度对齐，根据数据的规律，可以大致知道是每隔三个0一个有效数据。</p>
<p>上面存储了一个字符串：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>.rodata:0000000000400E58 aL3tMeT3llY0uS0 db &#39;L3t_ME_T3ll_Y0u_S0m3th1ng_1mp0rtant_A_{FL4G}_W0nt_b3_3X4ctly_th4t&#39;
</span></span><span style="display:flex;"><span>.rodata:0000000000400E58                 db &#39;_345y_t0_c4ptur3_H0wev3r_1T_w1ll_b3_C00l_1F_Y0u_g0t_1t&#39;,0
</span></span></code></pre></div><p>提取出来的字符串是：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>L3t_ME_T3ll_Y0u_S0m3th1ng_1mp0rtant_A_{FL4G}_W0nt_b3_3X4ctly_th4t_345y_t0_c4ptur3_H0wev3r_1T_w1ll_b3_C00l_1F_Y0u_g0t_1t
</span></span></code></pre></div><p>然后提取一下上面数组存储的数据：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="">unsigned</span> <span style="">char</span> ida_chars[] =
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00,
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>0x00, 0x00, 0x36, 0x00, 0x00, 0x00, 0x65, 0x00, 0x00, 0x00,
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>0x07, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x26, 0x00,
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>0x00, 0x00, 0x2D, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0D, 0x00,
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>0x00, 0x00, 0x56, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>0x03, 0x00, 0x00, 0x00, 0x65, 0x00, 0x00, 0x00, 0x03, 0x00,
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>0x00, 0x00, 0x2D, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00,
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>0x02, 0x00, 0x00, 0x00, 0x15, 0x00, 0x00, 0x00, 0x03, 0x00,
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>0x00, 0x00, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>0x29, 0x00, 0x00, 0x00, 0x44, 0x00, 0x00, 0x00, 0x44, 0x00,
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x44, 0x00, 0x00, 0x00,
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>0x2B, 0x00, 0x00, 0x00
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>现在知道一些已有的数据，下面需要对算法逻辑进行推导：
根据上面找到的关键指令进行C语言代码转化：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="">int</span> rax = 0;
</span></span><span style="display:flex;"><span><span style="">char</span> str[] =  <span style="font-style:italic">&#34;L3t_ME_T3ll_Y0u_S0m3th1ng_1mp0rtant_A_{FL4G}_W0nt_b3_3X4ctly_th4t_345y_t0_c4ptur3_H0wev3r_1T_w1ll_b3_C00l_1F_Y0u_g0t_1t&#34;</span>;
</span></span><span style="display:flex;"><span><span style="">unsigned</span> <span style="">char</span> ida_chars[] =
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00,
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>0x00, 0x00, 0x36, 0x00, 0x00, 0x00, 0x65, 0x00, 0x00, 0x00,
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>0x07, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x26, 0x00,
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>0x00, 0x00, 0x2D, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0D, 0x00,
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>0x00, 0x00, 0x56, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>0x03, 0x00, 0x00, 0x00, 0x65, 0x00, 0x00, 0x00, 0x03, 0x00,
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>0x00, 0x00, 0x2D, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00,
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>0x02, 0x00, 0x00, 0x00, 0x15, 0x00, 0x00, 0x00, 0x03, 0x00,
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>0x00, 0x00, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>0x29, 0x00, 0x00, 0x00, 0x44, 0x00, 0x00, 0x00, 0x44, 0x00,
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x44, 0x00, 0x00, 0x00,
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>0x2B, 0x00, 0x00, 0x00
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="font-weight:bold">if</span> (*(argv + rax) !=  str[ida_chars[rax*4]]) {
</span></span><span style="display:flex;"><span>	Error_exit();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>在继续跟逻辑，跟进上面的指令，整体看下汇编，进行C语言整合：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="">char</span> str[] =  <span style="font-style:italic">&#34;L3t_ME_T3ll_Y0u_S0m3th1ng_1mp0rtant_A_{FL4G}_W0nt_b3_3X4ctly_th4t_345y_t0_c4ptur3_H0wev3r_1T_w1ll_b3_C00l_1F_Y0u_g0t_1t&#34;</span>;
</span></span><span style="display:flex;"><span><span style="">unsigned</span> <span style="">char</span> ida_chars[] =
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>	0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00,
</span></span><span style="display:flex;"><span>	0x00, 0x00, 0x36, 0x00, 0x00, 0x00, 0x65, 0x00, 0x00, 0x00,
</span></span><span style="display:flex;"><span>	0x07, 0x00, 0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x26, 0x00,
</span></span><span style="display:flex;"><span>	0x00, 0x00, 0x2D, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
</span></span><span style="display:flex;"><span>	0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0D, 0x00,
</span></span><span style="display:flex;"><span>	0x00, 0x00, 0x56, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
</span></span><span style="display:flex;"><span>	0x03, 0x00, 0x00, 0x00, 0x65, 0x00, 0x00, 0x00, 0x03, 0x00,
</span></span><span style="display:flex;"><span>	0x00, 0x00, 0x2D, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00,
</span></span><span style="display:flex;"><span>	0x02, 0x00, 0x00, 0x00, 0x15, 0x00, 0x00, 0x00, 0x03, 0x00,
</span></span><span style="display:flex;"><span>	0x00, 0x00, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
</span></span><span style="display:flex;"><span>	0x29, 0x00, 0x00, 0x00, 0x44, 0x00, 0x00, 0x00, 0x44, 0x00,
</span></span><span style="display:flex;"><span>	0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x44, 0x00, 0x00, 0x00,
</span></span><span style="display:flex;"><span>	0x2B, 0x00, 0x00, 0x00
</span></span><span style="display:flex;"><span>	};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">for</span> (<span style="">int</span> i = 0; i &lt; 31; i++) {
</span></span><span style="display:flex;"><span>	<span style="font-weight:bold">if</span> (*(argv + i) !=  str[ida_chars[i*4]]) {
</span></span><span style="display:flex;"><span>	Error_exit();
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>现在主要逻辑基本已经整合成C语言代码，下面根据主要的逻辑，编写一个C语言代码进行求解：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="">#include</span> <span style="">&lt;stdio.h&gt;</span><span style="">
</span></span></span><span style="display:flex;"><span><span style=""></span>
</span></span><span style="display:flex;"><span><span style="">int</span> main()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>        <span style="">char</span> string[] = <span style="font-style:italic">&#34;L3t_ME_T3ll_Y0u_S0m3th1ng_1mp0rtant_A_{FL4G}_W0nt_b3_3X4ctly_th4t_345y_t0_c4ptur3_H0wev3r_1T_w1ll_b3_C00l_1F_Y0u_g0t_1&#34;</span>; 
</span></span><span style="display:flex;"><span>        <span style="">char</span> ida_chars[] =
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>          0x24, 0x00, 0x05, 0x36, 0x65, 0x07,  0x27, 0x26, 0x2D, 
</span></span><span style="display:flex;"><span>          0x01, 0x03, 0x00, 0x0D, 0x56, 0x01, 0x03, 0x65, 0x03,
</span></span><span style="display:flex;"><span>          0x2D, 0x16, 0x02, 0x15, 0x03, 0x65, 0x00, 0x29, 0x44, 
</span></span><span style="display:flex;"><span>          0x44, 0x01, 0x44, 0x2B
</span></span><span style="display:flex;"><span>        };
</span></span><span style="display:flex;"><span>        <span style="">char</span> flag[31];
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">for</span> (<span style="">int</span> i = 0; i &lt; 31; i++) {
</span></span><span style="display:flex;"><span>                flag[i] = string[ida_chars[i]];
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        printf(<span style="font-style:italic">&#34;%s</span><span style="font-weight:bold;font-style:italic">\n</span><span style="font-style:italic">&#34;</span>, flag);
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">return</span> 0;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>编译并运行程序，得到：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>ALEXCTF{W3_L0v3_C_W1th_CL45535}
</span></span></code></pre></div><p>补充知识：</p>
<blockquote>
<p>Linux x64 fastcall 调用约定</p>
<ul>
<li>Linux 下的调用约定叫做 “System V AMD64 ABI”，此约定主要在 Solaris，GNU/Linux，FreeBSD 和其他非微软OS上使用；</li>
<li>Linux 的 x64 下也只有一种函数调用约定，即 __fastcall ，其他调用约定的关键字会被忽略，也就是说 ABI 只有__fastcall ；</li>
<li>一个函数在调用时，如果参数个数小于等于 6 个时，前 6 个参数是从左至右依次存放于 RDI，RSI，RDX，RCX，R8，R9 寄存器里面，剩下的参数通过栈传递，从右至左顺序入栈；</li>
<li>如果参数个数大于 6 个时，前 5 个参数是从左至右依次存放于 RDI，RSI，RDX，RCX，RAX 寄存器里面，剩下的参数通过栈传递，从右至左顺序入栈；</li>
<li>对于系统调用，使用 R10 代替 RCX；</li>
</ul>
</blockquote>
<h2 id="easyre1">
  easyRE1
  <a class="heading-link" href="#easyre1">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h2>
<p>附件中是一个rar文件，解压后的文件夹含有两个文件
一个easy-32文件
一个easy-64文件</p>
<p>查看下文件的大致信息：
<img src="/images/XCTF-REVERSE-DAILY/Pasted_image_20220422045950.png" alt=""></p>
<p>ELF x64位程序，通过gcc进行编译的，没有壳
使用IDA pro 查看下程序</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>push    rbp
</span></span><span style="display:flex;"><span>mov     rbp, rsp
</span></span><span style="display:flex;"><span>sub     rsp, 120h
</span></span><span style="display:flex;"><span>mov     [rbp+var_114], edi
</span></span><span style="display:flex;"><span>mov     [rbp+var_120], rsi
</span></span><span style="display:flex;"><span>mov     rax, fs:28h
</span></span><span style="display:flex;"><span>mov     [rbp+var_8], rax
</span></span><span style="display:flex;"><span>xor     eax, eax
</span></span><span style="display:flex;"><span>mov     edi, offset s   ; &#34;What is the password?&#34;
</span></span><span style="display:flex;"><span>call    _puts
</span></span><span style="display:flex;"><span>lea     rax, [rbp+s1]
</span></span><span style="display:flex;"><span>mov     rdi, rax
</span></span><span style="display:flex;"><span>mov     eax, 0
</span></span><span style="display:flex;"><span>call    _gets
</span></span><span style="display:flex;"><span>lea     rax, [rbp+s1]
</span></span><span style="display:flex;"><span>mov     esi, offset s2  ; &#34;the password&#34;
</span></span><span style="display:flex;"><span>mov     rdi, rax        ; s1
</span></span><span style="display:flex;"><span>call    _strcmp
</span></span><span style="display:flex;"><span>test    eax, eax
</span></span><span style="display:flex;"><span>jnz     short loc_40068F
</span></span><span style="display:flex;"><span>mov     edi, offset aFlagDb2f62a36a ; &#34;FLAG:db2f62a36a018bce28e46d976e3f9864&#34;
</span></span><span style="display:flex;"><span>call    _puts
</span></span><span style="display:flex;"><span>jmp     short loc_400699
</span></span><span style="display:flex;"><span>loc_40068F:                             ; CODE XREF: main+5B↑j
</span></span><span style="display:flex;"><span>mov     edi, offset aWrong ; &#34;Wrong!!&#34;
</span></span><span style="display:flex;"><span>call    _puts
</span></span></code></pre></div><p>发现程序就挺简单的，关键信息就直接呈现出来了</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>mov     edi, offset aFlagDb2f62a36a ; &#34;FLAG:db2f62a36a018bce28e46d976e3f9864&#34;
</span></span></code></pre></div><p>这道题目的Flag应该就是：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>flag{db2f62a36a018bce28e46d976e3f9864}
</span></span></code></pre></div><h2 id="reversing-x64elf-100">
  Reversing-x64Elf-100
  <a class="heading-link" href="#reversing-x64elf-100">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h2>
<p>查看下文件信息，应该是Elf的文件，使用DIE查看下程序信息
<img src="/images/XCTF-REVERSE-DAILY/Pasted_image_20220422051546.png" alt=""></p>
<p>Elf x64程序，没有壳，gcc编译。
使用IDA看下，发现整个程序还是比较简单的，逻辑流程比较清晰</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>main            proc near               ; DATA XREF: start+1D↑o
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>s               = byte ptr -110h
</span></span><span style="display:flex;"><span>var_8           = qword ptr -8
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>; __unwind {
</span></span><span style="display:flex;"><span>push    rbp
</span></span><span style="display:flex;"><span>mov     rbp, rsp
</span></span><span style="display:flex;"><span>sub     rsp, 110h
</span></span><span style="display:flex;"><span>mov     rax, fs:28h
</span></span><span style="display:flex;"><span>mov     [rbp+var_8], rax
</span></span><span style="display:flex;"><span>xor     eax, eax
</span></span><span style="display:flex;"><span>mov     edi, offset format ; &#34;Enter the password: &#34;
</span></span><span style="display:flex;"><span>mov     eax, 0
</span></span><span style="display:flex;"><span>call    _printf
</span></span><span style="display:flex;"><span>mov     rdx, cs:stdin   ; stream
</span></span><span style="display:flex;"><span>lea     rax, [rbp+s]
</span></span><span style="display:flex;"><span>mov     esi, 0FFh       ; n
</span></span><span style="display:flex;"><span>mov     rdi, rax        ; s
</span></span><span style="display:flex;"><span>call    _fgets
</span></span><span style="display:flex;"><span>test    rax, rax
</span></span><span style="display:flex;"><span>jz      short loc_400866
</span></span><span style="display:flex;"><span>lea     rax, [rbp+s]
</span></span><span style="display:flex;"><span>mov     rdi, rax
</span></span><span style="display:flex;"><span>call    sub_4006FD
</span></span><span style="display:flex;"><span>test    eax, eax
</span></span><span style="display:flex;"><span>jnz     short loc_400855
</span></span><span style="display:flex;"><span>mov     edi, offset s   ; &#34;Nice!&#34;
</span></span><span style="display:flex;"><span>call    _puts
</span></span><span style="display:flex;"><span>mov     eax, 0
</span></span><span style="display:flex;"><span>jmp     short loc_40086B
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>loc_400855:                             ; CODE XREF: main+5A↑j
</span></span><span style="display:flex;"><span>	mov     edi, offset aIncorrectPassw ; &#34;Incorrect password!&#34;
</span></span><span style="display:flex;"><span>	call    _puts
</span></span><span style="display:flex;"><span>	mov     eax, 1
</span></span></code></pre></div><p>其实也就是一个判断，来判断flag的数据是否正确，主要应该就是对<code>sub_4006FD</code>函数的分析，
下面就需要进入<code>sub_4006FD</code>函数里面，观察这个函数的行为</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>sub_4006FD      proc near               ; CODE XREF: main+53↓p
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var_38          = qword ptr -38h
</span></span><span style="display:flex;"><span>var_24          = dword ptr -24h
</span></span><span style="display:flex;"><span>var_20          = qword ptr -20h
</span></span><span style="display:flex;"><span>var_18          = qword ptr -18h
</span></span><span style="display:flex;"><span>var_10          = qword ptr -10h
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>push    rbp
</span></span><span style="display:flex;"><span>mov     rbp, rsp
</span></span><span style="display:flex;"><span>mov     [rbp+var_38], rdi
</span></span><span style="display:flex;"><span>mov     [rbp+var_24], 0
</span></span><span style="display:flex;"><span>mov     [rbp+var_20], offset aDufhbmf ; &#34;Dufhbmf&#34;
</span></span><span style="display:flex;"><span>mov     [rbp+var_18], offset aPgImos ; &#34;pG`imos&#34;
</span></span><span style="display:flex;"><span>mov     [rbp+var_10], offset aEwuglpt ; &#34;ewUglpt&#34;
</span></span><span style="display:flex;"><span>mov     [rbp+var_24], 0
</span></span><span style="display:flex;"><span>jmp     short loc_40079B
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>loc_40072D:                        ; CODE XREF: sub_4006FD+A2↓j
</span></span><span style="display:flex;"><span>	mov     ecx, [rbp+var_24]
</span></span><span style="display:flex;"><span>	mov     edx, 55555556h
</span></span><span style="display:flex;"><span>	mov     eax, ecx
</span></span><span style="display:flex;"><span>	imul    edx
</span></span><span style="display:flex;"><span>	mov     eax, ecx
</span></span><span style="display:flex;"><span>	sar     eax, 1Fh
</span></span><span style="display:flex;"><span>	sub     edx, eax
</span></span><span style="display:flex;"><span>	mov     eax, edx
</span></span><span style="display:flex;"><span>	add     eax, eax
</span></span><span style="display:flex;"><span>	add     eax, edx
</span></span><span style="display:flex;"><span>	sub     ecx, eax
</span></span><span style="display:flex;"><span>	mov     edx, ecx
</span></span><span style="display:flex;"><span>	movsxd  rax, edx
</span></span><span style="display:flex;"><span>	mov     rsi, [rbp+rax*8+var_20]
</span></span><span style="display:flex;"><span>	mov     ecx, [rbp+var_24]
</span></span><span style="display:flex;"><span>	mov     edx, 55555556h
</span></span><span style="display:flex;"><span>	mov     eax, ecx
</span></span><span style="display:flex;"><span>	imul    edx
</span></span><span style="display:flex;"><span>	mov     eax, ecx
</span></span><span style="display:flex;"><span>	sar     eax, 1Fh
</span></span><span style="display:flex;"><span>	sub     edx, eax
</span></span><span style="display:flex;"><span>	mov     eax, edx
</span></span><span style="display:flex;"><span>	add     eax, eax
</span></span><span style="display:flex;"><span>	cdqe
</span></span><span style="display:flex;"><span>	add     rax, rsi
</span></span><span style="display:flex;"><span>	movzx   eax, byte ptr [rax]
</span></span><span style="display:flex;"><span>	movsx   edx, al
</span></span><span style="display:flex;"><span>	mov     eax, [rbp+var_24]
</span></span><span style="display:flex;"><span>	movsxd  rcx, eax
</span></span><span style="display:flex;"><span>	mov     rax, [rbp+var_38]
</span></span><span style="display:flex;"><span>	add     rax, rcx
</span></span><span style="display:flex;"><span>	movzx   eax, byte ptr [rax]
</span></span><span style="display:flex;"><span>	movsx   eax, al
</span></span><span style="display:flex;"><span>	sub     edx, eax
</span></span><span style="display:flex;"><span>	mov     eax, edx
</span></span><span style="display:flex;"><span>	cmp     eax, 1
</span></span><span style="display:flex;"><span>	jz      short loc_400797
</span></span><span style="display:flex;"><span>	mov     eax, 1
</span></span><span style="display:flex;"><span>	jmp     short loc_4007A6
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>loc_400797:                             ; CODE XREF: sub_4006FD+91↑j
</span></span><span style="display:flex;"><span>	add     [rbp+var_24], 1
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>loc_40079B:                             ; CODE XREF: sub_4006FD+2E↑j
</span></span><span style="display:flex;"><span>	cmp     [rbp+var_24], 0Bh
</span></span><span style="display:flex;"><span>	jle     short loc_40072D
</span></span><span style="display:flex;"><span>	mov     eax, 0
</span></span><span style="display:flex;"><span>loc_4007A6:                             ; CODE XREF: sub_4006FD+98↑j
</span></span><span style="display:flex;"><span>pop     rbp
</span></span><span style="display:flex;"><span>retn
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>sub_4006FD      endp
</span></span></code></pre></div><h3 id="算法分析">
  算法分析
  <a class="heading-link" href="#%e7%ae%97%e6%b3%95%e5%88%86%e6%9e%90">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h3>
<p>关键应该是根据汇编代码来进行算法解读
找到关键的汇编代码：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>jmp     short loc_40079B
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>loc_40072D:                        ; CODE XREF: sub_4006FD+A2↓j
</span></span><span style="display:flex;"><span>	mov     ecx, [rbp+var_24]
</span></span><span style="display:flex;"><span>	mov     edx, 55555556h
</span></span><span style="display:flex;"><span>	mov     eax, ecx
</span></span><span style="display:flex;"><span>	imul    edx
</span></span><span style="display:flex;"><span>	mov     eax, ecx
</span></span><span style="display:flex;"><span>	sar     eax, 1Fh
</span></span><span style="display:flex;"><span>	sub     edx, eax
</span></span><span style="display:flex;"><span>	mov     eax, edx
</span></span><span style="display:flex;"><span>	add     eax, eax
</span></span><span style="display:flex;"><span>	add     eax, edx
</span></span><span style="display:flex;"><span>	sub     ecx, eax
</span></span><span style="display:flex;"><span>	mov     edx, ecx
</span></span><span style="display:flex;"><span>	movsxd  rax, edx
</span></span><span style="display:flex;"><span>	mov     rsi, [rbp+rax*8+var_20]
</span></span><span style="display:flex;"><span>	mov     ecx, [rbp+var_24]
</span></span><span style="display:flex;"><span>	mov     edx, 55555556h
</span></span><span style="display:flex;"><span>	mov     eax, ecx
</span></span><span style="display:flex;"><span>	imul    edx
</span></span><span style="display:flex;"><span>	mov     eax, ecx
</span></span><span style="display:flex;"><span>	sar     eax, 1Fh
</span></span><span style="display:flex;"><span>	sub     edx, eax
</span></span><span style="display:flex;"><span>	mov     eax, edx
</span></span><span style="display:flex;"><span>	add     eax, eax
</span></span><span style="display:flex;"><span>	cdqe
</span></span><span style="display:flex;"><span>	add     rax, rsi
</span></span><span style="display:flex;"><span>	movzx   eax, byte ptr [rax]
</span></span><span style="display:flex;"><span>	movsx   edx, al
</span></span><span style="display:flex;"><span>	mov     eax, [rbp+var_24]
</span></span><span style="display:flex;"><span>	movsxd  rcx, eax
</span></span><span style="display:flex;"><span>	mov     rax, [rbp+var_38]
</span></span><span style="display:flex;"><span>	add     rax, rcx
</span></span><span style="display:flex;"><span>	movzx   eax, byte ptr [rax]
</span></span><span style="display:flex;"><span>	movsx   eax, al
</span></span><span style="display:flex;"><span>	sub     edx, eax
</span></span><span style="display:flex;"><span>	mov     eax, edx
</span></span><span style="display:flex;"><span>	cmp     eax, 1
</span></span><span style="display:flex;"><span>	jz      short loc_400797
</span></span><span style="display:flex;"><span>	mov     eax, 1
</span></span><span style="display:flex;"><span>	jmp     short loc_4007A6
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>loc_400797:                             ; CODE XREF: sub_4006FD+91↑j
</span></span><span style="display:flex;"><span>	add     [rbp+var_24], 1
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>loc_40079B:                             ; CODE XREF: sub_4006FD+2E↑j
</span></span><span style="display:flex;"><span>	cmp     [rbp+var_24], 0Bh
</span></span><span style="display:flex;"><span>	jle     short loc_40072D
</span></span><span style="display:flex;"><span>	mov     eax, 0
</span></span></code></pre></div><p>这一大段代码应该就是关键的汇编代码，开始像剥洋葱一样，一层一层剥下这个程序的逻辑</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>	mov     ecx, [rbp+var_24]
</span></span><span style="display:flex;"><span>	mov     edx, 55555556h
</span></span><span style="display:flex;"><span>	mov     eax, ecx
</span></span><span style="display:flex;"><span>	imul    edx
</span></span><span style="display:flex;"><span>	mov     eax, ecx
</span></span><span style="display:flex;"><span>	sar     eax, 1Fh
</span></span><span style="display:flex;"><span>	sub     edx, eax
</span></span><span style="display:flex;"><span>	mov     eax, edx
</span></span></code></pre></div><p>这段代码是 <code>[rpb+var_24] / 3</code> ，可能看不明白，在《C++反汇编揭秘》一书中给出了除法的汇编运算模型，也算是编译器的一个模型。
$$
\frac{\text{ecx} \cdot M}{2^{n+1}}
$$
这里的M是指<code>mov edx, 55555556h</code>中的数值<code>55555556h</code>，
这里的n是指<code>sar eax, 1Fh</code>中的数值<code>1Fh</code>
根据公式，可以推导出除数的计算公式</p>
<p>$$
除数 = \frac{2^{n+1}}{M}
$$
根据根据推导的除法公式进行计算，得到除数是3。（关于除法的汇编分析可以阅读看雪一个师傅写的博客：<a href="https://bbs.pediy.com/thread-261946.htm">[原创]#30天写作挑战#反汇编代码还原之除数为非2的幂-编程技术-看雪论坛-安全社区|安全招聘|bbs.pediy.com</a>）</p>
<p>现在可以清晰地明白了这段代码就是 ：n / 3</p>
<p>接下来，看下面一段代码：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>	add     eax, eax
</span></span><span style="display:flex;"><span>	add     eax, edx
</span></span><span style="display:flex;"><span>	sub     ecx, eax
</span></span><span style="display:flex;"><span>	mov     edx, ecx
</span></span></code></pre></div><p>这一段代码，是比较容易理解的，结合着上面的代码：</p>
<ul>
<li>eax = <code>n / 3</code></li>
<li>edx = <code>n / 3</code></li>
<li>ecx = <code>n</code>
根据信息，这段代码应该就是<code>n - 3 * (n / 3)</code>，可能有些人感觉很晕乎，着其实是取余运算，简言之，就是 <code>n % 3</code>，仔细分析下，就会发现和 <code>n % 3</code>的结果一致。</li>
</ul>
<p>现在这大段代码就是 <code>n % 3</code></p>
<p>继续往下走起！</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>	movsxd  rax, edx
</span></span><span style="display:flex;"><span>	mov     rsi, [rbp+rax*8+var_20]
</span></span></code></pre></div><p>这个非常简单，就是数组喽，即<code>rbp[n % 3]</code></p>
<p>接下来往下看</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>	mov     ecx, [rbp+var_24]
</span></span><span style="display:flex;"><span>	mov     edx, 55555556h
</span></span><span style="display:flex;"><span>	mov     eax, ecx
</span></span><span style="display:flex;"><span>	imul    edx
</span></span><span style="display:flex;"><span>	mov     eax, ecx
</span></span><span style="display:flex;"><span>	sar     eax, 1Fh
</span></span><span style="display:flex;"><span>	sub     edx, eax
</span></span><span style="display:flex;"><span>	mov     eax, edx
</span></span><span style="display:flex;"><span>	add     eax, eax
</span></span></code></pre></div><p>非常明显的除法，这段代码就是<code>2 * (n / 3)</code>
后面紧跟着一段代码：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>	cdqe
</span></span><span style="display:flex;"><span>	add     rax, rsi
</span></span><span style="display:flex;"><span>	movzx   eax, byte ptr [rax]
</span></span><span style="display:flex;"><span>	movsx   edx, al
</span></span></code></pre></div><p>其实就是对上面数据的一个整合，也就是</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>*(rbp[n % 3] + 2 * (n / 3))
</span></span></code></pre></div><p>现在最难读懂的部分已经过去了，剩下的部分就比较简单，一口气读完</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>	mov     eax, [rbp+var_24]
</span></span><span style="display:flex;"><span>	movsxd  rcx, eax
</span></span><span style="display:flex;"><span>	mov     rax, [rbp+var_38]
</span></span><span style="display:flex;"><span>	add     rax, rcx
</span></span><span style="display:flex;"><span>	movzx   eax, byte ptr [rax]
</span></span><span style="display:flex;"><span>	movsx   eax, al
</span></span></code></pre></div><p>直接读就行了，结合程序的信息：</p>
<ul>
<li>rax : <code>arg</code></li>
<li>rcx : <code>n</code></li>
</ul>
<p>所以这段代码就是</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>*(arg + n)
</span></span></code></pre></div><p>核心部分已经处理完毕了，再整体审计下代码得到</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="font-weight:bold">for</span> (<span style="">int</span> i = 0; i &lt;= 11; i++) {
</span></span><span style="display:flex;"><span>	<span style="font-weight:bold">if</span> ( *(rbp[ i % 3 ] + 2 * (i / 3)) - *(arg + i) != 1) {
</span></span><span style="display:flex;"><span>		<span style="font-weight:bold">return</span> 1;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>根据这样的代码，可以继续优化下，得到</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="font-weight:bold">for</span> (size_t i = 0; i &lt;= 11; i++) {
</span></span><span style="display:flex;"><span>	<span style="font-weight:bold">if</span> ( rbp[i % 3][2 * (i / 3)] - str[i] != 1) {
</span></span><span style="display:flex;"><span>		<span style="font-weight:bold">return</span> 1;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="求解">
  求解
  <a class="heading-link" href="#%e6%b1%82%e8%a7%a3">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h3>
<p>根据核心代码的分析，可以编写程序进行求解：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="">#include</span> <span style="">&lt;stdio.h&gt;</span><span style="">
</span></span></span><span style="display:flex;"><span><span style=""></span>
</span></span><span style="display:flex;"><span><span style="">int</span> main()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>        <span style="">char</span> *v3[4];
</span></span><span style="display:flex;"><span>        v3[0] = <span style="font-style:italic">&#34;Dufhbmf&#34;</span>;
</span></span><span style="display:flex;"><span>        v3[1] = <span style="font-style:italic">&#34;pG`imos&#34;</span>;
</span></span><span style="display:flex;"><span>        v3[2] = <span style="font-style:italic">&#34;ewUglpt&#34;</span>;
</span></span><span style="display:flex;"><span>        <span style="">char</span> flag[13] = {0};
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">for</span>(<span style="">int</span> i = 0; i &lt;= 11; i++)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>                flag[i] = v3[i%3][2*(i/3)] - 1;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        printf(<span style="font-style:italic">&#34;%s</span><span style="font-weight:bold;font-style:italic">\n</span><span style="font-style:italic">&#34;</span>, flag);
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">return</span> 0;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>编译并运行程序，得到</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>Code_Talkers
</span></span></code></pre></div><p>这道题目，主要考察运算的汇编理解。对于汇编的识别还是有一定要求的。至于我为什么不使用IDA pro的F5的Hex-rays插件的功能，我是想要进一步提高自身对于汇编语言的理解，而Hex-rays在很多时候都是无法使用，在真正的逆向工程中，更多的还是人工进行还原，而不是使用IDA的插件进行还原。而且，我是在进行练习，自然是希望挖掘到更多的知识点和技巧点。如果是比赛的话，肯定是更多采用F5的功能。</p>
<h2 id="babyre">
  BABYRE
  <a class="heading-link" href="#babyre">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h2>
<p>这道题目，有些技巧，不过总体还是挺有意思的。
看下程序信息先：
<img src="/images/XCTF-REVERSE-DAILY/Pasted_image_20220422233020.png" alt=""></p>
<p>ELF x64程序 GCC编译的程序
使用IDA pro看看</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>main            proc near               ; DATA XREF: _start+1D↑o
</span></span><span style="display:flex;"><span>s               = byte ptr -20h
</span></span><span style="display:flex;"><span>var_8           = dword ptr -8
</span></span><span style="display:flex;"><span>var_4           = dword ptr -4
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>; __unwind {
</span></span><span style="display:flex;"><span>                push    rbp
</span></span><span style="display:flex;"><span>                mov     rbp, rsp
</span></span><span style="display:flex;"><span>                sub     rsp, 20h
</span></span><span style="display:flex;"><span>                mov     [rbp+var_4], 0
</span></span><span style="display:flex;"><span>                jmp     short loc_400637
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>loc_400617:                             ; CODE XREF: main+38↓j
</span></span><span style="display:flex;"><span>                mov     eax, [rbp+var_4]
</span></span><span style="display:flex;"><span>                cdqe
</span></span><span style="display:flex;"><span>                movzx   eax, judge[rax]
</span></span><span style="display:flex;"><span>                xor     eax, 0Ch
</span></span><span style="display:flex;"><span>                mov     edx, eax
</span></span><span style="display:flex;"><span>                mov     eax, [rbp+var_4]
</span></span><span style="display:flex;"><span>                cdqe
</span></span><span style="display:flex;"><span>                mov     judge[rax], dl
</span></span><span style="display:flex;"><span>                add     [rbp+var_4], 1
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>loc_400637:                             ; CODE XREF: main+F↑j
</span></span><span style="display:flex;"><span>                cmp     [rbp+var_4], 0B5h
</span></span><span style="display:flex;"><span>                jle     short loc_400617
</span></span><span style="display:flex;"><span>                mov     edi, offset format ; &#34;Please input flag:&#34;
</span></span><span style="display:flex;"><span>                mov     eax, 0
</span></span><span style="display:flex;"><span>                call    _printf
</span></span><span style="display:flex;"><span>                lea     rax, [rbp+s]
</span></span><span style="display:flex;"><span>                mov     rsi, rax
</span></span><span style="display:flex;"><span>                mov     edi, offset a20s ; &#34;%20s&#34;
</span></span><span style="display:flex;"><span>                mov     eax, 0
</span></span><span style="display:flex;"><span>                call    ___isoc99_scanf
</span></span><span style="display:flex;"><span>                lea     rax, [rbp+s]
</span></span><span style="display:flex;"><span>                mov     rdi, rax        ; s
</span></span><span style="display:flex;"><span>                call    _strlen
</span></span><span style="display:flex;"><span>                mov     [rbp+var_8], eax
</span></span><span style="display:flex;"><span>                cmp     [rbp+var_8], 0Eh
</span></span><span style="display:flex;"><span>                jnz     short loc_400698
</span></span><span style="display:flex;"><span>                mov     edx, offset judge
</span></span><span style="display:flex;"><span>                lea     rax, [rbp+s]
</span></span><span style="display:flex;"><span>                mov     rdi, rax
</span></span><span style="display:flex;"><span>                call    rdx ; judge
</span></span><span style="display:flex;"><span>                test    eax, eax
</span></span><span style="display:flex;"><span>                jz      short loc_400698
</span></span><span style="display:flex;"><span>                mov     edi, offset s   ; &#34;Right!&#34;
</span></span><span style="display:flex;"><span>                call    _puts
</span></span><span style="display:flex;"><span>                jmp     short loc_4006A2
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>loc_400698:                             ; CODE XREF: main+72↑j
</span></span><span style="display:flex;"><span>                                        ; main+84↑j
</span></span><span style="display:flex;"><span>                mov     edi, offset aWrong ; &#34;Wrong!&#34;
</span></span><span style="display:flex;"><span>                call    _puts
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>loc_4006A2:                             ; CODE XREF: main+90↑j
</span></span><span style="display:flex;"><span>                mov     eax, 0
</span></span><span style="display:flex;"><span>                leave
</span></span><span style="display:flex;"><span>                retn
</span></span><span style="display:flex;"><span>; } // starts at 400606
</span></span><span style="display:flex;"><span>main            endp
</span></span></code></pre></div><h3 id="问题分析">
  问题分析
  <a class="heading-link" href="#%e9%97%ae%e9%a2%98%e5%88%86%e6%9e%90">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h3>
<p>主程序的汇编并不很难的样子，但是这里是有坑的</p>
<p>如果直接看主逻辑的话，没有什么难度。
主逻辑就是一个函数判断的问题，如果函数判断成功，就返回正确，错误就返回错误。
但是仔细看下，调用了一个Judge数据，相当于调用了数据。根据这个数据转换成函数会发现这个数据被混淆了。一直集中这个区域，就不知道怎么混淆。怎么跳出这个坑？这个的解决方法就挺简单的，放大一些自己的观测区域，能看到一些关键点</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>loc_400617:                             ; CODE XREF: main+38↓j
</span></span><span style="display:flex;"><span>                mov     eax, [rbp+var_4]
</span></span><span style="display:flex;"><span>                cdqe
</span></span><span style="display:flex;"><span>                movzx   eax, judge[rax]
</span></span><span style="display:flex;"><span>                xor     eax, 0Ch
</span></span><span style="display:flex;"><span>                mov     edx, eax
</span></span><span style="display:flex;"><span>                mov     eax, [rbp+var_4]
</span></span><span style="display:flex;"><span>                cdqe
</span></span><span style="display:flex;"><span>                mov     judge[rax], dl
</span></span><span style="display:flex;"><span>                add     [rbp+var_4], 1
</span></span><span style="display:flex;"><span>                
</span></span><span style="display:flex;"><span>loc_400637:                             ; CODE XREF: main+F↑j
</span></span><span style="display:flex;"><span>                cmp     [rbp+var_4], 0B5h
</span></span><span style="display:flex;"><span>                jle     short loc_400617
</span></span></code></pre></div><p>这段代码对<code>judge</code>数据进行异或处理，静态观察就不能看到准确的judge数据。如果想要正确看到这个函数的数据，就需要看到运行过程中的运行数据。解决方法有两个，一种是静态解决方案，另一种是动态解决方案。</p>
<h3 id="静态解决方案">
  静态解决方案
  <a class="heading-link" href="#%e9%9d%99%e6%80%81%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h3>
<p>采用静态反汇编的方案，也就比较简单，直接在IDA里面嵌入执行脚本，使用执行脚本对数据进行异或修改。IDA pro支持嵌入Python脚本进行异或操作来修改数据。进行异或来得到正确的数据。</p>
<p><img src="/images/XCTF-REVERSE-DAILY/Pasted_image_20220423113951.png" alt=""></p>
<p>运行一次，然后将judge数据段进行代码转换，就能得到相应的函数：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>judge           proc near               ; CODE XREF: main+80↑p
</span></span><span style="display:flex;"><span>                                        ; DATA XREF: main+16↑r ...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var_28          = qword ptr -28h
</span></span><span style="display:flex;"><span>var_20          = byte ptr -20h
</span></span><span style="display:flex;"><span>var_1F          = byte ptr -1Fh
</span></span><span style="display:flex;"><span>var_1E          = byte ptr -1Eh
</span></span><span style="display:flex;"><span>var_1D          = byte ptr -1Dh
</span></span><span style="display:flex;"><span>var_1C          = byte ptr -1Ch
</span></span><span style="display:flex;"><span>var_1B          = byte ptr -1Bh
</span></span><span style="display:flex;"><span>var_1A          = byte ptr -1Ah
</span></span><span style="display:flex;"><span>var_19          = byte ptr -19h
</span></span><span style="display:flex;"><span>var_18          = byte ptr -18h
</span></span><span style="display:flex;"><span>var_17          = byte ptr -17h
</span></span><span style="display:flex;"><span>var_16          = byte ptr -16h
</span></span><span style="display:flex;"><span>var_15          = byte ptr -15h
</span></span><span style="display:flex;"><span>var_14          = byte ptr -14h
</span></span><span style="display:flex;"><span>var_13          = byte ptr -13h
</span></span><span style="display:flex;"><span>var_4           = dword ptr -4
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                push    rbp
</span></span><span style="display:flex;"><span>                mov     rbp, rsp
</span></span><span style="display:flex;"><span>                mov     [rbp+var_28], rdi
</span></span><span style="display:flex;"><span>                mov     [rbp+var_20], 66h ; &#39;f&#39;
</span></span><span style="display:flex;"><span>                mov     [rbp+var_1F], 6Dh ; &#39;m&#39;
</span></span><span style="display:flex;"><span>                mov     [rbp+var_1E], 63h ; &#39;c&#39;
</span></span><span style="display:flex;"><span>                mov     [rbp+var_1D], 64h ; &#39;d&#39;
</span></span><span style="display:flex;"><span>                mov     [rbp+var_1C], 7Fh
</span></span><span style="display:flex;"><span>                mov     [rbp+var_1B], 6Bh ; &#39;k&#39;
</span></span><span style="display:flex;"><span>                mov     [rbp+var_1A], 37h ; &#39;7&#39;
</span></span><span style="display:flex;"><span>                mov     [rbp+var_19], 64h ; &#39;d&#39;
</span></span><span style="display:flex;"><span>                mov     [rbp+var_18], 3Bh ; &#39;;&#39;
</span></span><span style="display:flex;"><span>                mov     [rbp+var_17], 56h ; &#39;V&#39;
</span></span><span style="display:flex;"><span>                mov     [rbp+var_16], 60h ; &#39;`&#39;
</span></span><span style="display:flex;"><span>                mov     [rbp+var_15], 3Bh ; &#39;;&#39;
</span></span><span style="display:flex;"><span>                mov     [rbp+var_14], 6Eh ; &#39;n&#39;
</span></span><span style="display:flex;"><span>                mov     [rbp+var_13], 70h ; &#39;p&#39;
</span></span><span style="display:flex;"><span>                mov     [rbp+var_4], 0
</span></span><span style="display:flex;"><span>                jmp     short loc_600B71
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>loc_600B49:                             ; CODE XREF: judge+75↓j
</span></span><span style="display:flex;"><span>                mov     eax, [rbp+var_4]
</span></span><span style="display:flex;"><span>                movsxd  rdx, eax
</span></span><span style="display:flex;"><span>                mov     rax, [rbp+var_28]
</span></span><span style="display:flex;"><span>                add     rax, rdx
</span></span><span style="display:flex;"><span>                mov     edx, [rbp+var_4]
</span></span><span style="display:flex;"><span>                movsxd  rcx, edx
</span></span><span style="display:flex;"><span>                mov     rdx, [rbp+var_28]
</span></span><span style="display:flex;"><span>                add     rdx, rcx
</span></span><span style="display:flex;"><span>                movzx   edx, byte ptr [rdx]
</span></span><span style="display:flex;"><span>                mov     ecx, [rbp+var_4]
</span></span><span style="display:flex;"><span>                xor     edx, ecx
</span></span><span style="display:flex;"><span>                mov     [rax], dl
</span></span><span style="display:flex;"><span>                add     [rbp+var_4], 1
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>loc_600B71:                             ; CODE XREF: judge+47↑j
</span></span><span style="display:flex;"><span>                cmp     [rbp+var_4], 0Dh
</span></span><span style="display:flex;"><span>                jle     short loc_600B49
</span></span><span style="display:flex;"><span>                mov     [rbp+var_4], 0
</span></span><span style="display:flex;"><span>                jmp     short loc_600BA9
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>loc_600B80:                             ; CODE XREF: judge+AD↓j
</span></span><span style="display:flex;"><span>                mov     eax, [rbp+var_4]
</span></span><span style="display:flex;"><span>                movsxd  rdx, eax
</span></span><span style="display:flex;"><span>                mov     rax, [rbp+var_28]
</span></span><span style="display:flex;"><span>                add     rax, rdx
</span></span><span style="display:flex;"><span>                movzx   edx, byte ptr [rax]
</span></span><span style="display:flex;"><span>                mov     eax, [rbp+var_4]
</span></span><span style="display:flex;"><span>                cdqe
</span></span><span style="display:flex;"><span>                movzx   eax, [rbp+rax+var_20]
</span></span><span style="display:flex;"><span>                cmp     dl, al
</span></span><span style="display:flex;"><span>                jz      short loc_600BA5
</span></span><span style="display:flex;"><span>                mov     eax, 0
</span></span><span style="display:flex;"><span>                jmp     short loc_600BB4
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>loc_600BA5:                             ; CODE XREF: judge+9C↑j
</span></span><span style="display:flex;"><span>                add     [rbp+var_4], 1
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>loc_600BA9:                             ; CODE XREF: judge+7E↑j
</span></span><span style="display:flex;"><span>                cmp     [rbp+var_4], 0Dh
</span></span><span style="display:flex;"><span>                jle     short loc_600B80
</span></span><span style="display:flex;"><span>                mov     eax, 1
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>loc_600BB4:                             ; CODE XREF: judge+A3↑j
</span></span><span style="display:flex;"><span>                pop     rbp
</span></span><span style="display:flex;"><span>                retn
</span></span><span style="display:flex;"><span>judge           endp
</span></span></code></pre></div><h3 id="动态解决方案">
  动态解决方案
  <a class="heading-link" href="#%e5%8a%a8%e6%80%81%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h3>
<p>动态解决相对来说会更简单些，就是进行动态调试，使代码运行到指定位置，然后查看数据即可，这样配置可能会有些难度，需要更高的运行性能，但是总体操作相对更简单些。</p>
<p>断点断在<code>mov     edi, offset format ; &quot;Please input flag:&quot;</code> 这个指令就好，然后运行下动态调试。断在这个位置，查看下Judge数据就可以得到这个函数：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>judge proc near                         ; CODE XREF: main+80↑p
</span></span><span style="display:flex;"><span>                                        ; DATA XREF: main+16↑r ...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var_28= qword ptr -28h
</span></span><span style="display:flex;"><span>var_20= byte ptr -20h
</span></span><span style="display:flex;"><span>var_1F= byte ptr -1Fh
</span></span><span style="display:flex;"><span>var_1E= byte ptr -1Eh
</span></span><span style="display:flex;"><span>var_1D= byte ptr -1Dh
</span></span><span style="display:flex;"><span>var_1C= byte ptr -1Ch
</span></span><span style="display:flex;"><span>var_1B= byte ptr -1Bh
</span></span><span style="display:flex;"><span>var_1A= byte ptr -1Ah
</span></span><span style="display:flex;"><span>var_19= byte ptr -19h
</span></span><span style="display:flex;"><span>var_18= byte ptr -18h
</span></span><span style="display:flex;"><span>var_17= byte ptr -17h
</span></span><span style="display:flex;"><span>var_16= byte ptr -16h
</span></span><span style="display:flex;"><span>var_15= byte ptr -15h
</span></span><span style="display:flex;"><span>var_14= byte ptr -14h
</span></span><span style="display:flex;"><span>var_13= byte ptr -13h
</span></span><span style="display:flex;"><span>var_4= dword ptr -4
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>push    rbp
</span></span><span style="display:flex;"><span>mov     rbp, rsp
</span></span><span style="display:flex;"><span>mov     [rbp+var_28], rdi
</span></span><span style="display:flex;"><span>mov     [rbp+var_20], 66h ; &#39;f&#39;
</span></span><span style="display:flex;"><span>mov     [rbp+var_1F], 6Dh ; &#39;m&#39;
</span></span><span style="display:flex;"><span>mov     [rbp+var_1E], 63h ; &#39;c&#39;
</span></span><span style="display:flex;"><span>mov     [rbp+var_1D], 64h ; &#39;d&#39;
</span></span><span style="display:flex;"><span>mov     [rbp+var_1C], 7Fh
</span></span><span style="display:flex;"><span>mov     [rbp+var_1B], 6Bh ; &#39;k&#39;
</span></span><span style="display:flex;"><span>mov     [rbp+var_1A], 37h ; &#39;7&#39;
</span></span><span style="display:flex;"><span>mov     [rbp+var_19], 64h ; &#39;d&#39;
</span></span><span style="display:flex;"><span>mov     [rbp+var_18], 3Bh ; &#39;;&#39;
</span></span><span style="display:flex;"><span>mov     [rbp+var_17], 56h ; &#39;V&#39;
</span></span><span style="display:flex;"><span>mov     [rbp+var_16], 60h ; &#39;`&#39;
</span></span><span style="display:flex;"><span>mov     [rbp+var_15], 3Bh ; &#39;;&#39;
</span></span><span style="display:flex;"><span>mov     [rbp+var_14], 6Eh ; &#39;n&#39;
</span></span><span style="display:flex;"><span>mov     [rbp+var_13], 70h ; &#39;p&#39;
</span></span><span style="display:flex;"><span>mov     [rbp+var_4], 0
</span></span><span style="display:flex;"><span>jmp     short loc_600B71
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>loc_600B49:                             ; CODE XREF: judge+75↓j
</span></span><span style="display:flex;"><span>mov     eax, [rbp+var_4]
</span></span><span style="display:flex;"><span>movsxd  rdx, eax
</span></span><span style="display:flex;"><span>mov     rax, [rbp+var_28]
</span></span><span style="display:flex;"><span>add     rax, rdx
</span></span><span style="display:flex;"><span>mov     edx, [rbp+var_4]
</span></span><span style="display:flex;"><span>movsxd  rcx, edx
</span></span><span style="display:flex;"><span>mov     rdx, [rbp+var_28]
</span></span><span style="display:flex;"><span>add     rdx, rcx
</span></span><span style="display:flex;"><span>movzx   edx, byte ptr [rdx]
</span></span><span style="display:flex;"><span>mov     ecx, [rbp+var_4]
</span></span><span style="display:flex;"><span>xor     edx, ecx
</span></span><span style="display:flex;"><span>mov     [rax], dl
</span></span><span style="display:flex;"><span>add     [rbp+var_4], 1
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>loc_600B71:                             ; CODE XREF: judge+47↑j
</span></span><span style="display:flex;"><span>cmp     [rbp+var_4], 0Dh
</span></span><span style="display:flex;"><span>jle     short loc_600B49
</span></span><span style="display:flex;"><span>mov     [rbp+var_4], 0
</span></span><span style="display:flex;"><span>jmp     short loc_600BA9
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>loc_600B80:                             ; CODE XREF: judge+AD↓j
</span></span><span style="display:flex;"><span>mov     eax, [rbp+var_4]
</span></span><span style="display:flex;"><span>movsxd  rdx, eax
</span></span><span style="display:flex;"><span>mov     rax, [rbp+var_28]
</span></span><span style="display:flex;"><span>add     rax, rdx
</span></span><span style="display:flex;"><span>movzx   edx, byte ptr [rax]
</span></span><span style="display:flex;"><span>mov     eax, [rbp+var_4]
</span></span><span style="display:flex;"><span>cdqe
</span></span><span style="display:flex;"><span>movzx   eax, [rbp+rax+var_20]
</span></span><span style="display:flex;"><span>cmp     dl, al
</span></span><span style="display:flex;"><span>jz      short loc_600BA5
</span></span><span style="display:flex;"><span>mov     eax, 0
</span></span><span style="display:flex;"><span>jmp     short loc_600BB4
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>loc_600BA5:                             ; CODE XREF: judge+9C↑j
</span></span><span style="display:flex;"><span>add     [rbp+var_4], 1
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>loc_600BA9:                             ; CODE XREF: judge+7E↑j
</span></span><span style="display:flex;"><span>cmp     [rbp+var_4], 0Dh
</span></span><span style="display:flex;"><span>jle     short loc_600B80
</span></span><span style="display:flex;"><span>mov     eax, 1
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>loc_600BB4:                             ; CODE XREF: judge+A3↑j
</span></span><span style="display:flex;"><span>pop     rbp
</span></span><span style="display:flex;"><span>retn
</span></span><span style="display:flex;"><span>judge endp
</span></span></code></pre></div><h3 id="judge函数分析">
  judge函数分析
  <a class="heading-link" href="#judge%e5%87%bd%e6%95%b0%e5%88%86%e6%9e%90">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h3>
<p>现在找到了函数，就需要对函数进行分析来发现关键的判断逻辑，来进行关键步骤的推理分析与判断</p>
<p>对函数大致看一下，应该就是两个for循环了，第一个for循环是对参数进行异或操作，而第二个for循环是对局部变量进行操作。</p>
<p>一段一段地分析吧</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>                mov     [rbp+var_4], 0
</span></span><span style="display:flex;"><span>                jmp     short loc_600B71
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>loc_600B49:                             ; CODE XREF: judge+75↓j
</span></span><span style="display:flex;"><span>                mov     eax, [rbp+var_4]
</span></span><span style="display:flex;"><span>                movsxd  rdx, eax
</span></span><span style="display:flex;"><span>                mov     rax, [rbp+var_28]
</span></span><span style="display:flex;"><span>                add     rax, rdx
</span></span><span style="display:flex;"><span>                mov     edx, [rbp+var_4]
</span></span><span style="display:flex;"><span>                movsxd  rcx, edx
</span></span><span style="display:flex;"><span>                mov     rdx, [rbp+var_28]
</span></span><span style="display:flex;"><span>                add     rdx, rcx
</span></span><span style="display:flex;"><span>                movzx   edx, byte ptr [rdx]
</span></span><span style="display:flex;"><span>                mov     ecx, [rbp+var_4]
</span></span><span style="display:flex;"><span>                xor     edx, ecx
</span></span><span style="display:flex;"><span>                mov     [rax], dl
</span></span><span style="display:flex;"><span>                add     [rbp+var_4], 1
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>loc_600B71:                             ; CODE XREF: judge+47↑j
</span></span><span style="display:flex;"><span>                cmp     [rbp+var_4], 0Dh
</span></span><span style="display:flex;"><span>                jle     short loc_600B49
</span></span></code></pre></div><p>首先对于这段代码，要知道的一些信息：</p>
<ul>
<li><code>[rbp+var_4]</code> : i</li>
<li><code>[rbp+var_28]</code> : rdi &ndash;&gt; arg</li>
</ul>
<p>所以根据这些信息，可以对这段汇编代码进行还原</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="font-weight:bold">for</span> (<span style="">int</span> i = 0; i&lt;= 0xD; i++) {
</span></span><span style="display:flex;"><span>	*(arg+i) = *(arg+i)^i;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>接着看下面一个循环语句：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>                mov     [rbp+var_4], 0
</span></span><span style="display:flex;"><span>                jmp     short loc_600BA9
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>loc_600B80:                             ; CODE XREF: judge+AD↓j
</span></span><span style="display:flex;"><span>                mov     eax, [rbp+var_4]
</span></span><span style="display:flex;"><span>                movsxd  rdx, eax
</span></span><span style="display:flex;"><span>                mov     rax, [rbp+var_28]
</span></span><span style="display:flex;"><span>                add     rax, rdx
</span></span><span style="display:flex;"><span>                movzx   edx, byte ptr [rax]
</span></span><span style="display:flex;"><span>                mov     eax, [rbp+var_4]
</span></span><span style="display:flex;"><span>                cdqe
</span></span><span style="display:flex;"><span>                movzx   eax, [rbp+rax+var_20]
</span></span><span style="display:flex;"><span>                cmp     dl, al
</span></span><span style="display:flex;"><span>                jz      short loc_600BA5
</span></span><span style="display:flex;"><span>                mov     eax, 0
</span></span><span style="display:flex;"><span>                jmp     short loc_600BB4
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>loc_600BA5:                             ; CODE XREF: judge+9C↑j
</span></span><span style="display:flex;"><span>                add     [rbp+var_4], 1
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>loc_600BA9:                             ; CODE XREF: judge+7E↑j
</span></span><span style="display:flex;"><span>                cmp     [rbp+var_4], 0Dh
</span></span><span style="display:flex;"><span>                jle     short loc_600B80
</span></span></code></pre></div><p>这段代码应该就是核心判断的逻辑咯，需要知道点信息来进行审计：</p>
<ul>
<li><code>[rbp+var_4]</code> : i</li>
<li><code>[rbp+var_28]</code> : rdi &ndash;&gt; arg</li>
<li><code>[rbp+var_20]</code> : <code>str[0xD]</code></li>
</ul>
<p>根据这些信息进行代码还原，非常简单</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="font-weight:bold">for</span> (<span style="">int</span> i = 0; i &lt;= 0xD; i++) {
</span></span><span style="display:flex;"><span>	<span style="font-weight:bold">if</span>(*(arg+i) != str[i]) {
</span></span><span style="display:flex;"><span>		<span style="font-weight:bold">return</span> 1;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这个函数的核心逻辑代码已经有了，现在对这个函数的代码进行整合就能得到：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="">int</span> judge(<span style="">char</span> *arg) {
</span></span><span style="display:flex;"><span>	<span style="">char</span> str[0xD+1];
</span></span><span style="display:flex;"><span>	str[0] = <span style="font-style:italic">&#39;f&#39;</span>;
</span></span><span style="display:flex;"><span>	str[1] = <span style="font-style:italic">&#39;m&#39;</span>;
</span></span><span style="display:flex;"><span>	str[2] = <span style="font-style:italic">&#39;c&#39;</span>;
</span></span><span style="display:flex;"><span>	str[3] = <span style="font-style:italic">&#39;d&#39;</span>;
</span></span><span style="display:flex;"><span>	str[4] = 0x7F;
</span></span><span style="display:flex;"><span>	str[5] = <span style="font-style:italic">&#39;k&#39;</span>;
</span></span><span style="display:flex;"><span>	str[6] = <span style="font-style:italic">&#39;7&#39;</span>;
</span></span><span style="display:flex;"><span>	str[7] = <span style="font-style:italic">&#39;d&#39;</span>;
</span></span><span style="display:flex;"><span>	str[8] = <span style="font-style:italic">&#39;;&#39;</span>;
</span></span><span style="display:flex;"><span>	str[9] = <span style="font-style:italic">&#39;V&#39;</span>;
</span></span><span style="display:flex;"><span>	str[10] = <span style="font-style:italic">&#39;`&#39;</span>;
</span></span><span style="display:flex;"><span>	str[11] = <span style="font-style:italic">&#39;;&#39;</span>;
</span></span><span style="display:flex;"><span>	str[12] = <span style="font-style:italic">&#39;n&#39;</span>;
</span></span><span style="display:flex;"><span>	str[13] = <span style="font-style:italic">&#39;p&#39;</span>;
</span></span><span style="display:flex;"><span>	<span style="font-weight:bold">for</span> (<span style="">int</span> i = 0; i&lt;= 0xD; i++) {
</span></span><span style="display:flex;"><span>		arg[i] = arg[i]^i;
</span></span><span style="display:flex;"><span>		<span style="font-weight:bold">if</span>(arg[i] != str[i]) {
</span></span><span style="display:flex;"><span>			<span style="font-weight:bold">return</span> 1;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="font-weight:bold">return</span> 0;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="求解-1">
  求解
  <a class="heading-link" href="#%e6%b1%82%e8%a7%a3-1">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h3>
<p>现在Judge函数算是分析完成了，可以根据函数进行求解了</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="">#include</span> <span style="">&lt;stdio.h&gt;</span><span style="">
</span></span></span><span style="display:flex;"><span><span style="">#include</span> <span style="">&lt;string.h&gt;</span><span style="">
</span></span></span><span style="display:flex;"><span><span style=""></span>
</span></span><span style="display:flex;"><span><span style="">int</span> main()
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>      <span style="">char</span> data[15] = {0};
</span></span><span style="display:flex;"><span>      <span style="">char</span> temp[9] = {0};
</span></span><span style="display:flex;"><span>      <span style="">char</span> flag[14] = {0};
</span></span><span style="display:flex;"><span>      memcpy(data, <span style="font-style:italic">&#34;fmcd&#34;</span>, 4);
</span></span><span style="display:flex;"><span>      data[4] = 127;
</span></span><span style="display:flex;"><span>      memcpy(temp, <span style="font-style:italic">&#34;k7d;V`;np&#34;</span>, 9);
</span></span><span style="display:flex;"><span>      strcat(data,temp);
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold">for</span> (<span style="">int</span> i = 0; i &lt; 14; i++)
</span></span><span style="display:flex;"><span>      {
</span></span><span style="display:flex;"><span>          flag[i] = data[i] ^ i;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>      printf(<span style="font-style:italic">&#34;%s</span><span style="font-weight:bold;font-style:italic">\n</span><span style="font-style:italic">&#34;</span>, flag);
</span></span><span style="display:flex;"><span>      <span style="font-weight:bold">return</span> 0;
</span></span><span style="display:flex;"><span>  }
</span></span></code></pre></div><p>编译代码，并执行得到</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>flag{n1c3_j0b}k7d;V`;npfmcdk7d;V`;npf
</span></span></code></pre></div><p>flag就是前半部分，即<code>flag{n1c3_j0b}</code></p>
<p>这道题目也是可以使用IDA pro的Hex-Rays插件进行F5反编译的，和自己分析的结果基本上是一致的。本菜狗也只是想要提高一下自己的汇编水准，进行了相应的练习。因此并没有使用Hex-Rays插件进行反编译分析，而是直接查看汇编来进行阅读分析。</p>

      </div>


      <footer>
        


        <div id="disqus_thread"></div>
<script type="application/javascript">
    window.disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "yourdiscussshortname" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
        
        
      </footer>
    </article>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css"
    integrity="sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs" crossorigin="anonymous">
  
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js"
    integrity="sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx" crossorigin="anonymous"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js"
    integrity="sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR" crossorigin="anonymous"
    onload="renderMathInElement(document.body,
      {
        delimiters: [
          {left: '$$', right: '$$', display:true},
          {left: '$', right: '$', display:false},
          {left: '\\(', right: '\\)', display: false},
          {left: '\\[', right: '\\]', display: true}
        ]
      }
    );"></script>
  </section>

    </div>

    <footer class="footer">
  <section class="container">
    ©
    
      2019 -
    
    2022
     OrcasCode 
    ·
    
    Powered by <a href="https://gohugo.io/">Hugo</a> & <a href="https://github.com/luizdepra/hugo-coder/">Coder</a>.
    
  </section>
</footer>

  </main>

  
  
  <script src="/js/coder.min.236049395dc3682fb2719640872958e12f1f24067bb09c327b233e6290c7edac.js" integrity="sha256-I2BJOV3DaC&#43;ycZZAhylY4S8fJAZ7sJwyeyM&#43;YpDH7aw="></script>
  

  

  

  

  

  

  

  

  

  
</body>

</html>
